<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipeline Panic</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            color: #ff6b6b;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #gameContainer {
            border: 3px solid #4ecdc4;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
            background: #16213e;
            padding: 10px;
        }

        canvas {
            background: #87ceeb;
            display: block;
            cursor: crosshair;
        }

        #ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 800px;
            margin-top: 10px;
            font-size: 18px;
            font-weight: bold;
        }

        #leftUI {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        #rightUI {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .game-button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
            font-size: 14px;
            font-weight: bold;
            position: relative;
            z-index: 1000;
        }
        
        .game-button:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
        
        #pauseButton {
            background: #2196F3;
        }
        
        #pauseButton:hover {
            background: #1976D2;
        }

        #centerUI {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .ui-element {
            margin: 5px 0;
            padding: 5px 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
            pointer-events: auto;
        }

        #timerBar {
            width: 300px;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }

        #timerFill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            transition: width 0.1s linear;
        }

        #instructions {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #4ecdc4;
        }

        #phaseIndicator {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <h1>üö∞ Pipeline Panic üö∞</h1>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
    </div>

    <div id="ui">
        <div id="leftUI">
            <div class="ui-element" id="timerDisplay" style="font-size: 24px; font-weight: bold; color: #FFD700;">
                ‚è±Ô∏è <span id="timeLeft">15</span>s
            </div>
            <div class="ui-element">
                üéØ Ammo: <span id="ammoCount">0</span>
            </div>
            <div class="ui-element">
                <div style="display: flex; align-items: center;">
                    ‚õΩ Tank: 
                    <div id="tankContainer" style="width: 80px; height: 20px; border: 2px solid #fff; margin-left: 10px; position: relative; background: #333;">
                        <div id="tankFill" style="height: 100%; background: linear-gradient(90deg, #00BFFF, #00FFFF); width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="centerUI">
            <div class="ui-element" id="phaseIndicator">PHASE 1: COLLECT AMMO</div>
            <div id="timerBar">
                <div id="timerFill" style="width: 100%"></div>
            </div>
            <div class="ui-element" id="timerText" style="font-size: 18px; margin-top: 5px;">
                ‚è±Ô∏è Time: <span id="timeRemaining">15</span>s
            </div>
        </div>
        
        <div id="rightUI">
            <div class="ui-element">
                üèÜ Wave: <span id="waveCount">1</span>
            </div>
            <div class="ui-element">
                üíØ Score: <span id="score">0</span>
            </div>
            <div class="ui-element" id="powerUpDisplay" style="display: none;">
                ‚ö° Power: <span id="activePowerUp">None</span>
            </div>
            <div class="ui-element" style="display: flex; gap: 5px;">
                <button id="pauseButton" class="game-button" style="background: #2196F3;">Pause</button>
                <button id="exitButton" class="game-button">Exit</button>
            </div>
        </div>
    </div>

    <div id="instructions">
        <strong>Phase 1:</strong> Click and drag to dig tunnels ‚Ä¢ Fill tank (at least 20%, 100% to skip timer)!<br>
        <strong>Phase 2:</strong> A/D or ‚Üê/‚Üí to move gun ‚Ä¢ Unlimited auto-fire ‚Ä¢ Destroy boulders within 1 minute!
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            GRID_WIDTH: 160,
            GRID_HEIGHT: 80,
            CELL_SIZE: 5,
            AMMO_PHASE_TIME: 15000, // 15 seconds
            BOULDER_PHASE_TIME: 60000, // 1 minute for boulder phase
            GRAVITY: 0.2,
            GUN_SPEED: 5,
            BULLET_SPEED: 8,
            // Polish parameters
            MIN_BOUNCE_HEIGHT: 14.0, // High minimum bounce
            BOUNCE_VARIATION: 0.08, // Even less variation for stability
            AUTO_FIRE_RATE: 150, // milliseconds between shots
            DIG_RADIUS: 2.0, // radius in grid cells for fine dirt
            CAMERA_SHAKE_INTENSITY: 4,
            PARTICLE_COUNT: 12,
            // Water simulation parameters
            WATER_FLOW_RATE: 0.15, // Much slower water flow from tap
            WATER_PRESSURE: 0.3, // Less aggressive horizontal spread
            WATER_VISCOSITY: 0.98, // Slightly thicker water
            MAX_WATER_PER_CELL: 1.0, // Maximum water in a cell
            MIN_WATER_FLOW: 0.02, // Minimum water to flow
            TAP_WIDTH: 4, // Width of tap in grid cells
            TAP_X: 80, // X position of tap in grid
            TAP_Y: 0 // Y position of tap in grid - at very top
        };

        // Terrain Types
        const TERRAIN = {
            SKY: 0,
            SAND: 1,
            WALL: 2,
            TANK: 3
        };

        // Game States
        const GAME_STATE = {
            MENU: 'menu',
            PHASE1: 'phase1',
            PHASE2: 'phase2',
            GAME_OVER: 'game_over'
        };

        // Game Class
        class PipelinePanicGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Game state
                this.currentState = GAME_STATE.MENU;
                this.wave = 1;
                this.score = 0;
                this.ammoCount = 0;
                this.fuelCollected = 0;
                this.showInstructions = false;
                this.showLeaderboard = false;
                this.leaderboard = this.loadLeaderboard();
                this.showCustomization = false;
                this.isPaused = false;
                this.showPauseMenu = false;
                this.showPauseInstructions = false;
                
                // Load saved customization
                this.selectedSkin = localStorage.getItem('pipelinePanicSkin') || 'default';
                this.selectedFuelColor = localStorage.getItem('pipelinePanicFuelColor') || 'blue';
                
                // Phase 1 variables
                this.grid = [];
                this.waterGrid = []; // Grid-based water simulation
                this.grassGrid = []; // Track original grass positions
                this.waterFlowing = false;
                this.countdownTimer = 3000; // 3 second countdown
                this.phaseStarted = false;
                this.phaseTimer = CONFIG.AMMO_PHASE_TIME;
                this.fuelLevel = 0; // Gradual fuel level 0-100
                this.dustParticles = [];
                this.dirtDecorations = []; // Decorative objects in dirt
                this.tankFull = false; // Track if tank reached 100%
                this.showingCongrats = false; // Showing congratulations screen
                this.showingWaveScreen = false; // Showing wave announcement
                this.waveScreenTimer = 0; // Timer for wave screen
                
                // Phase 2 variables
                this.gun = { x: 400, y: 380, width: 40, height: 20 };
                this.baseGunWidth = 40;
                this.baseGunHeight = 20;
                this.scaleFactor = 1.0;
                this.bullets = [];
                this.boulders = [];
                this.lastAutoFire = 0;
                this.impactParticles = [];
                this.boulderPhaseTimer = CONFIG.BOULDER_PHASE_TIME;
                this.transitioning = false; // Flag to prevent multiple wave transitions
                this.pendingSplits = []; // Array to store boulders that will split
                
                // Visual effects
                this.cameraShake = { x: 0, y: 0, intensity: 0 };
                this.muzzleFlash = 0;
                this.backgroundIndex = 0;
                this.backgrounds = ['morning', 'afternoon', 'evening', 'night'];
                this.currentBackground = this.backgrounds[Math.floor(Math.random() * this.backgrounds.length)];
                
                // Sound system
                this.audioContext = null;
                this.sounds = {};
                this.initSounds();
                
                // Power-ups
                this.powerUps = [];
                this.collectedPowerUps = [];
                this.activePowerUp = null;
                this.showingPowerUpSelection = false;
                this.boulderPhaseStartCountdown = 0;
                
                // Customization
                this.selectedSkin = 'default';
                this.selectedFuelColor = 'blue';
                this.skins = {
                    default: { name: 'Classic', color: '#4169E1', gradient: ['#5C7CFA', '#4169E1', '#364FC7'] },
                    red: { name: 'Crimson', color: '#DC143C', gradient: ['#FF6B6B', '#DC143C', '#B91C1C'] },
                    green: { name: 'Forest', color: '#228B22', gradient: ['#4ADE80', '#228B22', '#166534'] },
                    purple: { name: 'Royal', color: '#9370DB', gradient: ['#C084FC', '#9370DB', '#7C3AED'] },
                    gold: { name: 'Golden', color: '#FFD700', gradient: ['#FDE047', '#FFD700', '#EAB308'] }
                };
                this.fuelColors = {
                    blue: { name: 'Ocean', color: '#00BFFF' },
                    green: { name: 'Toxic', color: '#00FF00' },
                    purple: { name: 'Plasma', color: '#FF00FF' },
                    gold: { name: 'Honey', color: '#FFD700' },
                    red: { name: 'Lava', color: '#FF6347' }
                };
                
                // Input handling
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                
                this.updateUI(); // Hide UI initially since we're in menu
                this.setupEventListeners();
                this.gameLoop();
            }
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 191, b: 255 }; // Default to blue if parsing fails
            }
            
            initSounds() {
                // Initialize Web Audio API for sound effects
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                    return;
                }
            }
            
            playSound(type, frequency = null, duration = 0.1) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                switch(type) {
                    case 'shoot':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(300, this.audioContext.currentTime + 0.05);
                        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                        duration = 0.05;
                        break;
                    case 'hit':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(220, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        duration = 0.1;
                        break;
                    case 'burst':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(110, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(55, this.audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        duration = 0.2;
                        
                        // Add noise burst
                        const bufferSize = this.audioContext.sampleRate * 0.1;
                        const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                        const output = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) {
                            output[i] = Math.random() * 2 - 1;
                        }
                        const noise = this.audioContext.createBufferSource();
                        noise.buffer = buffer;
                        const noiseGain = this.audioContext.createGain();
                        noise.connect(noiseGain);
                        noiseGain.connect(this.audioContext.destination);
                        noiseGain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        noise.start();
                        noise.stop(this.audioContext.currentTime + 0.1);
                        break;
                    case 'waterFill':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(660 + Math.random() * 100, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.05, this.audioContext.currentTime);
                        duration = 0.05;
                        break;
                    case 'dig':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(150 + Math.random() * 50, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                        duration = 0.05;
                        break;
                    case 'powerup':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(523, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(1047, this.audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        duration = 0.3;
                        break;
                }
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            startGame() {
                this.currentState = GAME_STATE.MENU; // Stay in menu state during wave screen
                this.wave = 1;
                this.score = 0;
                this.fuelLevel = 0;
                this.phaseStarted = false;
                this.countdownTimer = 3000;
                this.phaseTimer = CONFIG.AMMO_PHASE_TIME; // Reset phase timer!
                
                // Clear all UI states
                this.showInstructions = false;
                this.showCustomization = false;
                this.showLeaderboard = false;
                this.showingPowerUpSelection = false;
                this.isPaused = false;
                this.showPauseMenu = false;
                this.showPauseInstructions = false;
                
                // Clear game over state
                this.gameOverName = '';
                this.gameOverNameSubmitted = false;
                this.showingWaveScreen = true;  // Show wave screen
                this.waveScreenTimer = 2000;    // Show for 2 seconds
                
                // Clear all game data
                this.bullets = [];
                this.boulders = [];
                this.waterGrid = [];
                this.dustParticles = [];
                this.impactParticles = [];
                this.pendingSplits = [];
                this.dirtDecorations = [];
                this.transitioning = false;
                this.activePowerUp = null;
                this.collectedPowerUps = [];
                this.powerUps = [];
                this.boulderPhaseStartCountdown = 0;
                this.scaleFactor = 1.0;
                this.tankFull = false;
                this.showingCongrats = false;
                
                // Grid initialization will happen after wave screen in startNextWavePhase
            }

            initializeGrid() {
                // Create grid for Phase 1 (much finer cells for realistic dirt)
                this.grid = [];
                this.waterGrid = [];
                this.waterDelay = []; // Track delay for water falling
                this.grassGrid = []; // Track original grass positions
                
                for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                    this.grid[y] = [];
                    this.waterGrid[y] = [];
                    this.waterDelay[y] = [];
                    this.grassGrid[y] = [];
                    for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                        if (y < 12) {
                            this.grid[y][x] = TERRAIN.SKY;
                        } else if (y < 68) {
                            this.grid[y][x] = TERRAIN.SAND;
                        } else {
                            this.grid[y][x] = TERRAIN.WALL;
                        }
                        this.waterGrid[y][x] = 0; // Initialize water amount to 0
                        this.waterDelay[y][x] = 0; // Initialize delay to 0
                        
                        // Mark original grass positions (dirt adjacent to sky)
                        if (y === 12 && this.grid[y][x] === TERRAIN.SAND) {
                            this.grassGrid[y][x] = true;
                        } else {
                            this.grassGrid[y][x] = false;
                        }
                    }
                }
                
                // Always randomize tank and tap positions
                if (this.wave === 1) {
                    // First wave - easier positions
                    this.tankX = Math.floor(Math.random() * 2) * 120; // Far left or far right
                    this.tankY = 60;
                    this.tapX = 60 + Math.floor(Math.random() * 40);
                    this.tapY = 0; // Always at very top
                } else {
                    // All other waves - full randomization
                    // Tank can be left, middle, or right
                    const tankPositions = [0, 64, 128];
                    this.tankX = tankPositions[Math.floor(Math.random() * tankPositions.length)];
                    this.tankY = 55 + Math.floor(Math.random() * 10);
                    
                    // Tap position varies widely horizontally, but always at top
                    this.tapX = 20 + Math.floor(Math.random() * 120);
                    this.tapY = 0; // Always at very top
                    
                    // Ensure tap isn't directly above tank for challenge
                    if (Math.abs(this.tapX - this.tankX - 16) < 20) {
                        this.tapX = (this.tapX + 60) % 140 + 20;
                    }
                }
                
                // Add tank area
                const tankWidth = 32;
                const tankHeight = 20;
                for (let x = this.tankX; x < this.tankX + tankWidth && x < CONFIG.GRID_WIDTH; x++) {
                    for (let y = this.tankY; y < this.tankY + tankHeight && y < CONFIG.GRID_HEIGHT; y++) {
                        this.grid[y][x] = TERRAIN.TANK;
                    }
                }

                // Add strategic walls between tap and tank
                this.addStrategicWalls();
                
                // Reset phase started flag for countdown
                this.phaseStarted = false;
                this.countdownTimer = 3000;
                this.waterFlowing = false;
                
                // Add power-ups based on wave
                this.powerUps = [];
                const powerUpCount = Math.min(Math.floor(this.wave / 2) + 1, 4); // 1-4 power-ups
                for (let i = 0; i < powerUpCount; i++) {
                    let x, y;
                    // Find valid position for power-up
                    do {
                        x = 20 + Math.floor(Math.random() * 120);
                        y = 25 + Math.floor(Math.random() * 35);
                    } while (this.grid[y][x] !== TERRAIN.SAND);
                    
                    // Different power-up types
                    const types = ['rapidFire', 'doubleDamage', 'spreadShot'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    
                    this.powerUps.push({ x, y, collected: false, type });
                }
                
                // Add decorative objects in dirt
                this.addDirtDecorations();
                
                // Debug: Log positions
                console.log(`Wave ${this.wave}: Tank at (${this.tankX}, ${this.tankY}), Tap at (${this.tapX}, ${this.tapY})`);
            }
            
            addDirtDecorations() {
                // Clear previous decorations
                this.dirtDecorations = [];
                
                // Add fewer decorations - just 3-6 scattered around
                const decorationCount = 3 + Math.floor(Math.random() * 4);
                const decorationTypes = ['bone', 'rock', 'stone', 'fossil'];
                
                for (let i = 0; i < decorationCount; i++) {
                    let x, y;
                    let attempts = 0;
                    
                    // Find valid position in dirt
                    do {
                        x = Math.floor(Math.random() * CONFIG.GRID_WIDTH);
                        y = 15 + Math.floor(Math.random() * 50);
                        attempts++;
                    } while ((this.grid[y] && this.grid[y][x] !== TERRAIN.SAND || 
                              this.isNearPowerUp(x, y) || 
                              this.isNearTank(x, y)) && 
                              attempts < 50);
                    
                    if (attempts < 50) {
                        const type = decorationTypes[Math.floor(Math.random() * decorationTypes.length)];
                        // Bones are bigger than other decorations
                        const scale = type === 'bone' ? 
                            1.2 + Math.random() * 0.8 : // Bones: 1.2 to 2.0
                            0.7 + Math.random() * 0.6;   // Others: 0.7 to 1.3
                        const rotation = Math.random() * Math.PI * 2; // Random rotation 0-360 degrees
                        this.dirtDecorations.push({ x, y, type, scale, rotation });
                    }
                }
            }
            
            isNearPowerUp(x, y) {
                for (const powerUp of this.powerUps) {
                    if (Math.abs(powerUp.x - x) < 5 && Math.abs(powerUp.y - y) < 5) {
                        return true;
                    }
                }
                return false;
            }
            
            isNearTank(x, y) {
                return x >= this.tankX - 5 && x <= this.tankX + 37 && 
                       y >= this.tankY - 5 && y <= this.tankY + 25;
            }
            
            addStrategicWalls() {
                // Calculate path from tap to tank
                const tapCenterX = this.tapX;
                const tankCenterX = this.tankX + 16;
                const pathStartY = this.tapY + 10;
                const pathEndY = this.tankY - 5;
                
                // Add blocking wall in the direct path
                if (this.wave > 1) {
                    const blockY = Math.floor((pathStartY + pathEndY) / 2);
                    const blockX = Math.floor((tapCenterX + tankCenterX) / 2);
                    
                    // Create a wall that forces water to go around
                    for (let x = blockX - 10; x < blockX + 10; x++) {
                        if (x >= 0 && x < CONFIG.GRID_WIDTH && this.grid[blockY][x] === TERRAIN.SAND) {
                            this.grid[blockY][x] = TERRAIN.WALL;
                        }
                    }
                }
            }
            
            addWaveComplexity() {
                // Progressive obstacle difficulty with challenging puzzles
                if (this.wave <= 2) {
                    // Waves 1-2: Introduction to puzzle mechanics
                    this.addPathBlockers(1);
                    this.addSimpleDetour();
                } else if (this.wave <= 4) {
                    // Waves 3-4: Multiple paths and choices
                    this.addPathBlockers(2);
                    this.addLShapedWalls(1);
                    this.addFakePaths(1);
                    this.addZigzagPath(1);
                    this.addStoneChunks(2 + Math.floor(this.wave / 2));
                } else if (this.wave <= 6) {
                    // Waves 5-6: Much harder - Complex routing puzzles
                    this.addPathBlockers(3); // Increased from 2
                    this.addLShapedWalls(3); // Increased from 2
                    this.addFloatingPlatforms(2); // Increased from 1
                    this.addFakePaths(3); // Increased from 2
                    this.addZigzagPath(3); // Increased from 2
                    this.addUTurnPuzzle();
                    this.addOneWayValves();
                    this.addMazeSection(1); // Added maze section
                    this.addStoneChunks(6 + this.wave); // Increased from 4
                } else if (this.wave <= 8) {
                    // Waves 7-8: Advanced puzzles - even harder
                    this.addPathBlockers(4); // Increased from 3
                    this.addLShapedWalls(3); // Increased from 2
                    this.addFloatingPlatforms(3); // Increased from 2
                    this.addMazeSection(2); // Increased from 1
                    this.addFakePaths(3); // Increased from 2
                    this.addSpiralPuzzle();
                    this.addZigzagPath(3); // Increased from 2
                    this.addWaterReservoirs();
                    this.addUTurnPuzzle(); // Added U-turn
                    this.addStoneChunks(8 + this.wave); // Increased from 6
                } else {
                    // Waves 9+: Maximum complexity with intricate puzzles
                    this.addPathBlockers(4); // Increased from 3
                    this.addLShapedWalls(4); // Increased from 3
                    this.addFloatingPlatforms(3); // Increased from 2
                    this.addMazeSection(Math.min(this.wave - 8, 4)); // Increased max from 3
                    this.addFakePaths(4); // Increased from 3
                    this.addSpiralPuzzle();
                    this.addUTurnPuzzle();
                    this.addMultiLevelPuzzle();
                    this.addOneWayValves();
                    this.addWaterReservoirs();
                    this.addStoneChunks(10 + this.wave); // Increased from 8
                }
            }
            
            addPathBlockers(count) {
                // Add obstacles specifically in the path from tap to tank
                const tapX = this.tapX;
                const tankX = this.tankX + 16;
                const tapY = this.tapY + 10;
                const tankY = this.tankY;
                
                for (let i = 0; i < count; i++) {
                    // Calculate a point along the path
                    const t = (i + 1) / (count + 1);
                    const blockX = Math.floor(tapX + (tankX - tapX) * t);
                    const blockY = Math.floor(tapY + (tankY - tapY) * t);
                    
                    // Add obstacle near this point
                    const size = 3 + Math.floor(Math.random() * 3);
                    const offsetX = Math.floor((Math.random() - 0.5) * 20);
                    const offsetY = Math.floor((Math.random() - 0.5) * 10);
                    
                    for (let dx = -size/2; dx < size/2; dx++) {
                        for (let dy = -size/2; dy < size/2; dy++) {
                            const x = blockX + offsetX + dx;
                            const y = blockY + offsetY + dy;
                            if (x >= 0 && x < CONFIG.GRID_WIDTH && y >= 0 && y < CONFIG.GRID_HEIGHT &&
                                this.grid[y][x] === TERRAIN.SAND) {
                                this.grid[y][x] = TERRAIN.WALL;
                            }
                        }
                    }
                }
            }
            
            addSimpleWalls(count) {
                // This method is no longer used - replaced by addPathBlockers
                // Keeping for backwards compatibility
                this.addPathBlockers(count);
            }
            
            addLShapedWalls(count) {
                for (let i = 0; i < count; i++) {
                    // Place L-shaped walls near the water flow path
                    const targetX = this.tankX + 16 + (Math.random() - 0.5) * 60;
                    const targetY = 30 + Math.floor(Math.random() * 20);
                    
                    const x = Math.max(10, Math.min(CONFIG.GRID_WIDTH - 20, Math.floor(targetX)));
                    const y = Math.max(20, Math.min(50, targetY));
                    
                    // Horizontal part
                    const hLength = 6 + Math.floor(Math.random() * 4);
                    for (let dx = 0; dx < hLength; dx++) {
                        if (x + dx < CONFIG.GRID_WIDTH && this.grid[y][x + dx] === TERRAIN.SAND) {
                            this.grid[y][x + dx] = TERRAIN.WALL;
                        }
                    }
                    
                    // Vertical part
                    const vLength = 4 + Math.floor(Math.random() * 4);
                    const goUp = Math.random() < 0.5;
                    for (let dy = 0; dy < vLength; dy++) {
                        const yPos = goUp ? y - dy : y + dy;
                        if (yPos >= 0 && yPos < CONFIG.GRID_HEIGHT && this.grid[yPos][x] === TERRAIN.SAND) {
                            this.grid[yPos][x] = TERRAIN.WALL;
                        }
                    }
                }
            }
            
            addFloatingPlatforms(count) {
                for (let i = 0; i < count; i++) {
                    // Place platforms above the tank area to force indirect paths
                    const baseX = this.tankX + Math.floor(Math.random() * 40) - 10;
                    const x = Math.max(10, Math.min(CONFIG.GRID_WIDTH - 20, baseX));
                    const y = this.tankY - 15 - Math.floor(Math.random() * 15);
                    
                    if (y > 20) {
                        const width = 8 + Math.floor(Math.random() * 8);
                        
                        for (let dx = 0; dx < width; dx++) {
                            if (x + dx < CONFIG.GRID_WIDTH && this.grid[y][x + dx] === TERRAIN.SAND) {
                                this.grid[y][x + dx] = TERRAIN.WALL;
                            }
                        }
                        
                        // Add small vertical walls on ends sometimes
                        if (Math.random() < 0.5) {
                            for (let dy = 1; dy < 4; dy++) {
                                if (y + dy < CONFIG.GRID_HEIGHT && this.grid[y + dy][x] === TERRAIN.SAND) {
                                    this.grid[y + dy][x] = TERRAIN.WALL;
                                }
                                if (x + width - 1 < CONFIG.GRID_WIDTH && y + dy < CONFIG.GRID_HEIGHT && 
                                    this.grid[y + dy][x + width - 1] === TERRAIN.SAND) {
                                    this.grid[y + dy][x + width - 1] = TERRAIN.WALL;
                                }
                            }
                        }
                    }
                }
            }
            
            addMazeSection(complexity) {
                // Place maze sections near tank approach
                const mazeX = Math.max(10, Math.min(CONFIG.GRID_WIDTH - 40, 
                    this.tankX + Math.floor((Math.random() - 0.5) * 40)));
                const mazeY = Math.max(30, this.tankY - 25);
                
                // Create a maze that blocks direct access to tank
                for (let i = 0; i < complexity; i++) {
                    // Vertical walls with strategic gaps
                    const wallHeight = 8 + Math.floor(Math.random() * 4);
                    for (let y = 0; y < wallHeight; y++) {
                        if (mazeY + y < CONFIG.GRID_HEIGHT && mazeX + i * 10 < CONFIG.GRID_WIDTH &&
                            this.grid[mazeY + y][mazeX + i * 10] === TERRAIN.SAND) {
                            // Add gaps for water flow
                            if (y !== 3 && y !== wallHeight - 2) {
                                this.grid[mazeY + y][mazeX + i * 10] = TERRAIN.WALL;
                            }
                        }
                    }
                    
                    // Horizontal connectors at different heights
                    const connectY = mazeY + (i % 2 === 0 ? 2 : wallHeight - 3);
                    for (let x = 0; x < 8; x++) {
                        if (mazeX + i * 10 + x < CONFIG.GRID_WIDTH && connectY < CONFIG.GRID_HEIGHT &&
                            this.grid[connectY][mazeX + i * 10 + x] === TERRAIN.SAND) {
                            // Leave gap in middle
                            if (x < 3 || x > 5) {
                                this.grid[connectY][mazeX + i * 10 + x] = TERRAIN.WALL;
                            }
                        }
                    }
                }
                
                // Add diagonal barriers for extra challenge
                if (complexity > 1) {
                    for (let i = 0; i < 5; i++) {
                        const dx = mazeX + i * 3;
                        const dy = mazeY + i * 2;
                        if (dx < CONFIG.GRID_WIDTH && dy < CONFIG.GRID_HEIGHT && 
                            this.grid[dy][dx] === TERRAIN.SAND) {
                            this.grid[dy][dx] = TERRAIN.WALL;
                        }
                    }
                }
            }
            
            addSimpleDetour() {
                // Create a simple wall that forces a detour
                const midX = (this.tapX + this.tankX + 16) / 2;
                const midY = (this.tapY + this.tankY) / 2;
                
                // Horizontal barrier
                for (let x = -15; x <= 15; x++) {
                    const wallX = Math.floor(midX + x);
                    if (wallX >= 0 && wallX < CONFIG.GRID_WIDTH && 
                        this.grid[Math.floor(midY)][wallX] === TERRAIN.SAND) {
                        this.grid[Math.floor(midY)][wallX] = TERRAIN.WALL;
                    }
                }
            }
            
            addFakePaths(count) {
                // Create tempting paths that lead to dead ends
                for (let i = 0; i < count; i++) {
                    const side = Math.random() < 0.5 ? -1 : 1;
                    const fakeX = this.tankX + 16 + side * (25 + Math.random() * 15);
                    const fakeY = this.tankY - 20 - Math.random() * 15;
                    
                    if (fakeX < 10 || fakeX > CONFIG.GRID_WIDTH - 10 || fakeY < 20) continue;
                    
                    // Create inviting entrance with gradual narrowing
                    for (let y = 0; y < 15; y++) {
                        const width = 10 - Math.floor(y * 0.6);
                        const wallY = Math.floor(fakeY + y);
                        if (wallY >= CONFIG.GRID_HEIGHT) break;
                        
                        // Left wall
                        if (fakeX - width >= 0 && this.grid[wallY][Math.floor(fakeX - width)] === TERRAIN.SAND) {
                            this.grid[wallY][Math.floor(fakeX - width)] = TERRAIN.WALL;
                        }
                        // Right wall  
                        if (fakeX + width < CONFIG.GRID_WIDTH && this.grid[wallY][Math.floor(fakeX + width)] === TERRAIN.SAND) {
                            this.grid[wallY][Math.floor(fakeX + width)] = TERRAIN.WALL;
                        }
                    }
                    
                    // Seal the bottom
                    const bottomY = Math.floor(fakeY + 15);
                    if (bottomY < CONFIG.GRID_HEIGHT) {
                        for (let x = -4; x <= 4; x++) {
                            const wallX = Math.floor(fakeX + x);
                            if (wallX >= 0 && wallX < CONFIG.GRID_WIDTH &&
                                this.grid[bottomY][wallX] === TERRAIN.SAND) {
                                this.grid[bottomY][wallX] = TERRAIN.WALL;
                            }
                        }
                    }
                }
            }
            
            addZigzagPath(complexity) {
                // Force water to flow in a zigzag pattern
                const startX = this.tapX;
                const startY = this.tapY + 10;
                const segmentHeight = 8;
                const segmentWidth = 20 + complexity * 5;
                
                for (let i = 0; i < complexity + 2; i++) {
                    const y = startY + i * segmentHeight;
                    if (y >= CONFIG.GRID_HEIGHT - 15) break;
                    
                    // Alternating barriers
                    if (i % 2 === 0) {
                        // Block right side, leave gap on left
                        for (let x = startX - 5; x < startX + segmentWidth; x++) {
                            if (x >= 0 && x < CONFIG.GRID_WIDTH && y < CONFIG.GRID_HEIGHT &&
                                this.grid[y][x] === TERRAIN.SAND) {
                                this.grid[y][x] = TERRAIN.WALL;
                            }
                        }
                    } else {
                        // Block left side, leave gap on right
                        for (let x = startX - segmentWidth; x < startX + 5; x++) {
                            if (x >= 0 && x < CONFIG.GRID_WIDTH && y < CONFIG.GRID_HEIGHT &&
                                this.grid[y][x] === TERRAIN.SAND) {
                                this.grid[y][x] = TERRAIN.WALL;
                            }
                        }
                    }
                }
            }
            
            addUTurnPuzzle() {
                // Create a U-turn that forces water to go up before going down
                const centerX = (this.tapX + this.tankX + 16) / 2;
                const baseY = this.tankY - 25;
                
                if (baseY < 30) return;
                
                // Create U-shaped walls
                for (let y = 0; y < 20; y++) {
                    const wallY = baseY + y;
                    if (wallY >= CONFIG.GRID_HEIGHT) break;
                    
                    // Left wall of U
                    for (let x = -15; x < -12; x++) {
                        const wallX = Math.floor(centerX + x);
                        if (wallX >= 0 && wallX < CONFIG.GRID_WIDTH &&
                            this.grid[wallY][wallX] === TERRAIN.SAND) {
                            this.grid[wallY][wallX] = TERRAIN.WALL;
                        }
                    }
                    
                    // Right wall of U
                    for (let x = 12; x < 15; x++) {
                        const wallX = Math.floor(centerX + x);
                        if (wallX >= 0 && wallX < CONFIG.GRID_WIDTH &&
                            this.grid[wallY][wallX] === TERRAIN.SAND) {
                            this.grid[wallY][wallX] = TERRAIN.WALL;
                        }
                    }
                }
                
                // Bottom of U
                const bottomY = baseY + 20;
                if (bottomY < CONFIG.GRID_HEIGHT) {
                    for (let x = -15; x <= 15; x++) {
                        const wallX = Math.floor(centerX + x);
                        if (wallX >= 0 && wallX < CONFIG.GRID_WIDTH &&
                            this.grid[bottomY][wallX] === TERRAIN.SAND) {
                            this.grid[bottomY][wallX] = TERRAIN.WALL;
                        }
                    }
                }
                
                // Add a barrier above to force going around
                for (let x = -8; x <= 8; x++) {
                    const wallX = Math.floor(centerX + x);
                    const wallY = baseY - 5;
                    if (wallX >= 0 && wallX < CONFIG.GRID_WIDTH && wallY >= 0 &&
                        this.grid[wallY][wallX] === TERRAIN.SAND) {
                        this.grid[wallY][wallX] = TERRAIN.WALL;
                    }
                }
            }
            
            addSpiralPuzzle() {
                // Create a spiral that requires careful path planning
                const centerX = this.tankX + 16 + (Math.random() - 0.5) * 30;
                const centerY = this.tankY - 30;
                
                if (centerX < 25 || centerX > CONFIG.GRID_WIDTH - 25 || centerY < 25) return;
                
                // Create spiral walls
                let angle = 0;
                let radius = 4;
                const maxRadius = 18;
                
                while (radius < maxRadius) {
                    const x = Math.floor(centerX + Math.cos(angle) * radius);
                    const y = Math.floor(centerY + Math.sin(angle) * radius);
                    
                    if (x >= 0 && x < CONFIG.GRID_WIDTH && y >= 0 && y < CONFIG.GRID_HEIGHT &&
                        this.grid[y][x] === TERRAIN.SAND) {
                        this.grid[y][x] = TERRAIN.WALL;
                        
                        // Make walls thicker for outer spiral
                        if (radius > 10) {
                            const x2 = Math.floor(centerX + Math.cos(angle) * (radius - 1));
                            const y2 = Math.floor(centerY + Math.sin(angle) * (radius - 1));
                            if (x2 >= 0 && x2 < CONFIG.GRID_WIDTH && y2 >= 0 && y2 < CONFIG.GRID_HEIGHT &&
                                this.grid[y2][x2] === TERRAIN.SAND) {
                                this.grid[y2][x2] = TERRAIN.WALL;
                            }
                        }
                    }
                    
                    angle += 0.2;
                    radius += 0.08;
                }
            }
            
            addMultiLevelPuzzle() {
                // Create a multi-level puzzle that requires thinking in 3D
                const baseX = (this.tapX + this.tankX + 16) / 2;
                const levels = 3;
                
                for (let level = 0; level < levels; level++) {
                    const levelY = this.tapY + 15 + level * 12;
                    if (levelY >= CONFIG.GRID_HEIGHT - 20) break;
                    
                    // Create platforms with gaps
                    for (let x = -25; x <= 25; x++) {
                        // Leave gaps for water to fall through
                        if (Math.abs(x - level * 8) > 3) {
                            const wallX = Math.floor(baseX + x);
                            if (wallX >= 0 && wallX < CONFIG.GRID_WIDTH &&
                                this.grid[levelY][wallX] === TERRAIN.SAND) {
                                this.grid[levelY][wallX] = TERRAIN.WALL;
                            }
                        }
                    }
                    
                    // Add side walls to guide flow
                    for (let y = 0; y < 8; y++) {
                        const wallY = levelY - y;
                        if (wallY < 0) continue;
                        
                        // Left guide wall
                        const leftX = Math.floor(baseX - 25 + level * 3);
                        if (leftX >= 0 && leftX < CONFIG.GRID_WIDTH &&
                            this.grid[wallY][leftX] === TERRAIN.SAND) {
                            this.grid[wallY][leftX] = TERRAIN.WALL;
                        }
                        
                        // Right guide wall
                        const rightX = Math.floor(baseX + 25 - level * 3);
                        if (rightX >= 0 && rightX < CONFIG.GRID_WIDTH &&
                            this.grid[wallY][rightX] === TERRAIN.SAND) {
                            this.grid[wallY][rightX] = TERRAIN.WALL;
                        }
                    }
                }
            }
            
            addOneWayValves() {
                // Create narrow passages that require pressure buildup
                const numValves = Math.min(2 + Math.floor(this.wave / 3), 4);
                
                for (let i = 0; i < numValves; i++) {
                    const valveX = this.tapX + (Math.random() - 0.5) * 60;
                    const valveY = this.tapY + 20 + i * 15;
                    
                    if (valveX < 20 || valveX > CONFIG.GRID_WIDTH - 20 || valveY >= CONFIG.GRID_HEIGHT - 20) continue;
                    
                    // Create a constriction point
                    for (let y = -3; y <= 3; y++) {
                        for (let x = -8; x <= 8; x++) {
                            const wallX = Math.floor(valveX + x);
                            const wallY = Math.floor(valveY + y);
                            
                            // Leave only a tiny gap in the middle
                            if (Math.abs(x) > 1 || Math.abs(y) > 0) {
                                if (wallX >= 0 && wallX < CONFIG.GRID_WIDTH && wallY >= 0 && wallY < CONFIG.GRID_HEIGHT &&
                                    this.grid[wallY][wallX] === TERRAIN.SAND) {
                                    this.grid[wallY][wallX] = TERRAIN.WALL;
                                }
                            }
                        }
                    }
                }
            }
            
            addWaterReservoirs() {
                // Create reservoirs that must be filled before water can overflow
                const numReservoirs = Math.min(1 + Math.floor(this.wave / 4), 3);
                
                for (let i = 0; i < numReservoirs; i++) {
                    const resX = this.tankX + 16 + (Math.random() - 0.5) * 40;
                    const resY = this.tankY - 30 - i * 20;
                    
                    if (resX < 15 || resX > CONFIG.GRID_WIDTH - 15 || resY < 15) continue;
                    
                    // Create reservoir walls
                    const depth = 8 + Math.floor(Math.random() * 5);
                    const width = 10 + Math.floor(Math.random() * 8);
                    
                    // Bottom and sides
                    for (let y = 0; y < depth; y++) {
                        const wallY = Math.floor(resY + y);
                        if (wallY >= CONFIG.GRID_HEIGHT) break;
                        
                        // Left wall
                        const leftX = Math.floor(resX - width/2);
                        if (leftX >= 0 && this.grid[wallY][leftX] === TERRAIN.SAND) {
                            this.grid[wallY][leftX] = TERRAIN.WALL;
                        }
                        
                        // Right wall
                        const rightX = Math.floor(resX + width/2);
                        if (rightX < CONFIG.GRID_WIDTH && this.grid[wallY][rightX] === TERRAIN.SAND) {
                            this.grid[wallY][rightX] = TERRAIN.WALL;
                        }
                        
                        // Bottom
                        if (y === depth - 1) {
                            for (let x = -width/2; x <= width/2; x++) {
                                const bottomX = Math.floor(resX + x);
                                if (bottomX >= 0 && bottomX < CONFIG.GRID_WIDTH &&
                                    this.grid[wallY][bottomX] === TERRAIN.SAND) {
                                    this.grid[wallY][bottomX] = TERRAIN.WALL;
                                }
                            }
                        }
                    }
                }
            }
            
            addStoneChunks(count) {
                // Add random large stone chunks as obstacles
                const minSize = 5 + Math.floor(this.wave / 3);
                const maxSize = 10 + Math.floor(this.wave / 2);
                
                for (let i = 0; i < count; i++) {
                    // Random position avoiding critical paths
                    let chunkX = Math.floor(Math.random() * (CONFIG.GRID_WIDTH - maxSize * 2) + maxSize);
                    let chunkY = Math.floor(Math.random() * (CONFIG.GRID_HEIGHT - maxSize * 2 - 40) + 40);
                    
                    // Avoid placing directly between tap and tank
                    const directPath = Math.abs(chunkX - (this.tapX + this.tankX + 16) / 2) < 20 &&
                                     chunkY > this.tapY && chunkY < this.tankY;
                    if (directPath) {
                        chunkX += (Math.random() < 0.5 ? -30 : 30);
                    }
                    
                    // Create irregular stone shape
                    const width = minSize + Math.floor(Math.random() * (maxSize - minSize));
                    const height = minSize + Math.floor(Math.random() * (maxSize - minSize));
                    
                    // Base rectangle
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const gridX = chunkX + x;
                            const gridY = chunkY + y;
                            
                            if (gridX >= 0 && gridX < CONFIG.GRID_WIDTH &&
                                gridY >= 0 && gridY < CONFIG.GRID_HEIGHT &&
                                this.grid[gridY][gridX] === TERRAIN.SAND) {
                                // Create irregular edges
                                const edgeDistance = Math.min(x, y, width - x - 1, height - y - 1);
                                const probability = edgeDistance === 0 ? 0.6 : 
                                                  edgeDistance === 1 ? 0.8 : 1.0;
                                
                                if (Math.random() < probability) {
                                    this.grid[gridY][gridX] = TERRAIN.WALL;
                                }
                            }
                        }
                    }
                    
                    // Add some random protrusions
                    for (let j = 0; j < 3; j++) {
                        const protX = chunkX + Math.floor(Math.random() * width);
                        const protY = chunkY + Math.floor(Math.random() * height);
                        const protSize = 2 + Math.floor(Math.random() * 3);
                        
                        for (let py = -protSize; py <= protSize; py++) {
                            for (let px = -protSize; px <= protSize; px++) {
                                const dist = Math.abs(px) + Math.abs(py);
                                if (dist <= protSize) {
                                    const gridX = protX + px;
                                    const gridY = protY + py;
                                    if (gridX >= 0 && gridX < CONFIG.GRID_WIDTH &&
                                        gridY >= 0 && gridY < CONFIG.GRID_HEIGHT &&
                                        this.grid[gridY][gridX] === TERRAIN.SAND) {
                                        this.grid[gridY][gridX] = TERRAIN.WALL;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                    
                    // Only allow digging after countdown in Phase 1
                    if (this.currentState === GAME_STATE.PHASE1 && this.phaseStarted && !this.showingCongrats) {
                    this.mouse.down = true;
                    } else if (this.currentState !== GAME_STATE.PHASE1) {
                        this.mouse.down = true;
                    }
                    
                    if (this.showPauseMenu) {
                        this.handlePauseMenuClick();
                    } else if (this.currentState === GAME_STATE.MENU) {
                        this.handleMenuClick();
                    } else if (this.currentState === GAME_STATE.PHASE1) {
                        if (this.showingCongrats) {
                            this.handleCongratsClick();
                        }
                    } else if (this.currentState === GAME_STATE.PHASE2) {
                        if (this.showingPowerUpSelection) {
                            this.handlePowerUpClick();
                        } else if (!this.isPaused) {
                        this.fireBullet();
                        }
                    } else if (this.currentState === GAME_STATE.GAME_OVER) {
                        this.handleGameOverClick();
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                    
                    if (this.mouse.down && this.currentState === GAME_STATE.PHASE1 && !this.showingCongrats && this.phaseStarted && !this.isPaused) {
                        this.digTerrain();
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.down = false;
                });

                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    // Handle escape key for pause
                    if (e.key === 'Escape' && (this.currentState === GAME_STATE.PHASE1 || this.currentState === GAME_STATE.PHASE2)) {
                        this.togglePause();
                    }
                    
                    // Handle name input in game over screen
                    if (this.currentState === GAME_STATE.GAME_OVER && !this.gameOverNameSubmitted) {
                        if (e.key === 'Enter') {
                            this.submitGameOverName();
                        } else if (e.key === 'Backspace') {
                            this.gameOverName = this.gameOverName.slice(0, -1);
                        } else if (e.key.length === 1 && this.gameOverName.length < 20) {
                            this.gameOverName += e.key;
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Exit button
                document.getElementById('exitButton').addEventListener('click', () => {
                    if (confirm('Are you sure you want to exit to main menu?')) {
                        this.exitToMenu();
                    }
                });
                
                // Pause button
                document.getElementById('pauseButton').addEventListener('click', () => {
                    this.togglePause();
                });
            }
            
            handleMenuClick() {
                const centerX = 400;
                const centerY = 160; // Updated to match new button positions
                
                if (!this.showInstructions && !this.showCustomization && !this.showLeaderboard) {
                    // Check play button
                    if (this.mouse.x > centerX - 100 && this.mouse.x < centerX + 100 &&
                        this.mouse.y > centerY - 30 && this.mouse.y < centerY + 10) {
                        this.startGame();
                    }
                    // Check instructions button
                    else if (this.mouse.x > centerX - 100 && this.mouse.x < centerX + 100 &&
                             this.mouse.y > centerY + 40 && this.mouse.y < centerY + 80) {
                        this.showInstructions = true;
                    }
                    // Check customization button
                    else if (this.mouse.x > centerX - 100 && this.mouse.x < centerX + 100 &&
                             this.mouse.y > centerY + 100 && this.mouse.y < centerY + 140) {
                        this.showCustomization = true;
                    }
                    // Check leaderboard button
                    else if (this.mouse.x > centerX - 100 && this.mouse.x < centerX + 100 &&
                             this.mouse.y > centerY + 160 && this.mouse.y < centerY + 200) {
                        this.showLeaderboard = true;
                    }
                } else if (this.showInstructions) {
                    // Back button from instructions
                    if (this.mouse.x > centerX - 50 && this.mouse.x < centerX + 50 &&
                        this.mouse.y > 340 && this.mouse.y < 380) {
                        this.showInstructions = false;
                    }
                } else if (this.showCustomization) {
                    // Check skin selection
                    let skinX = 80;
                    for (const [key, skin] of Object.entries(this.skins)) {
                        if (this.mouse.x > skinX && this.mouse.x < skinX + 120 &&
                            this.mouse.y > 140 && this.mouse.y < 180) {
                            this.selectedSkin = key;
                            localStorage.setItem('pipelinePanicSkin', key);
                            this.playSound('powerup');
                        }
                        skinX += 130;
                    }
                    
                    // Check fuel color selection
                    let fuelX = 80;
                    for (const [key, fuel] of Object.entries(this.fuelColors)) {
                        if (this.mouse.x > fuelX && this.mouse.x < fuelX + 120 &&
                            this.mouse.y > 220 && this.mouse.y < 260) {
                            this.selectedFuelColor = key;
                            localStorage.setItem('pipelinePanicFuelColor', key);
                            this.playSound('powerup');
                        }
                        fuelX += 130;
                    }
                    
                    // Back button from customization
                    if (this.mouse.x > centerX - 50 && this.mouse.x < centerX + 50 &&
                        this.mouse.y > 290 && this.mouse.y < 330) {
                        this.showCustomization = false;
                    }
                } else if (this.showLeaderboard) {
                    // Back button from leaderboard
                    if (this.mouse.x > centerX - 50 && this.mouse.x < centerX + 50 &&
                        this.mouse.y > 340 && this.mouse.y < 380) {
                        this.showLeaderboard = false;
                    }
                }
            }

            digTerrain() {
                const centerX = this.mouse.x / CONFIG.CELL_SIZE;
                const centerY = this.mouse.y / CONFIG.CELL_SIZE;
                
                // Circular digging with soft edges
                for (let dy = -CONFIG.DIG_RADIUS - 1; dy <= CONFIG.DIG_RADIUS + 1; dy++) {
                    for (let dx = -CONFIG.DIG_RADIUS - 1; dx <= CONFIG.DIG_RADIUS + 1; dx++) {
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Softer edge - random chance based on distance
                        const digChance = distance <= CONFIG.DIG_RADIUS ? 1.0 : 
                                        distance <= CONFIG.DIG_RADIUS + 0.5 ? 0.7 :
                                        distance <= CONFIG.DIG_RADIUS + 1 ? 0.3 : 0;
                        
                        if (Math.random() < digChance) {
                            const gridX = Math.floor(centerX + dx);
                            const gridY = Math.floor(centerY + dy);
                            
                            if (gridX >= 0 && gridX < CONFIG.GRID_WIDTH && 
                                gridY >= 0 && gridY < CONFIG.GRID_HEIGHT &&
                                this.grid[gridY][gridX] === TERRAIN.SAND) {
                                
                                this.grid[gridY][gridX] = TERRAIN.SKY;
                                
                                // Remove any decorations at this position
                                this.dirtDecorations = this.dirtDecorations.filter(decoration => 
                                    decoration.x !== gridX || decoration.y !== gridY
                                );
                                
                                // Play dig sound (more frequent)
                                if (Math.random() < 0.5) {
                                    this.playSound('dig');
                                }
                                
                                // Create realistic dust particles - more variation
                                const particleCount = 2 + Math.floor(Math.random() * 3);
                                for (let i = 0; i < particleCount; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = Math.random() * 2 + 1;
                                    this.dustParticles.push({
                                        x: gridX * CONFIG.CELL_SIZE + Math.random() * CONFIG.CELL_SIZE,
                                        y: gridY * CONFIG.CELL_SIZE + Math.random() * CONFIG.CELL_SIZE,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed - Math.random() * 2,
                                        life: 15 + Math.random() * 25,
                                        maxLife: 40,
                                        size: 1 + Math.random() * 2,
                                        color: Math.random() < 0.5 ? '#8B4513' : '#A0522D'
                                    });
                                }
                            }
                        }
                    }
                }
            }

            updatePhase1() {
                // Guard against running this when not in phase 1
                if (this.currentState !== GAME_STATE.PHASE1) {
                    return;
                }
                
                // Handle countdown timer
                if (!this.phaseStarted) {
                    this.countdownTimer -= 16;
                    if (this.countdownTimer <= 0) {
                        this.phaseStarted = true;
                        this.waterFlowing = true;
                    }
                    return; // Don't update phase timer during countdown
                }
                
                // Update phase timer
                this.phaseTimer -= 16; // Assuming 60fps
                
                if (this.phaseTimer <= 0) {
                    // Ensure we only transition once
                    if (this.currentState === GAME_STATE.PHASE1) {
                        this.transitionToPhase2();
                    }
                    return;
                }

                // Update dust particles
                for (let i = this.dustParticles.length - 1; i >= 0; i--) {
                    const dust = this.dustParticles[i];
                    dust.x += dust.vx;
                    dust.y += dust.vy;
                    dust.vx *= 0.95;
                    dust.vy *= 0.95;
                    dust.life--;
                    
                    if (dust.life <= 0) {
                        this.dustParticles.splice(i, 1);
                    }
                }

                // Spawn water from tap
                if (this.waterFlowing) {
                    // Add water at dynamic tap location
                    const tapX = this.tapX || CONFIG.TAP_X;
                    const tapY = this.tapY || CONFIG.TAP_Y;
                    
                    for (let i = 0; i < CONFIG.TAP_WIDTH; i++) {
                        const x = tapX - Math.floor(CONFIG.TAP_WIDTH/2) + i;
                        if (x >= 0 && x < CONFIG.GRID_WIDTH && tapY < CONFIG.GRID_HEIGHT) {
                            // Make water flow faster in higher waves to compensate for harder puzzles
                            let flowRate = CONFIG.WATER_FLOW_RATE;
                            if (this.wave >= 5) {
                                flowRate = CONFIG.WATER_FLOW_RATE * 1.2; // 20% faster water flow from wave 5+
                            }
                            this.waterGrid[tapY][x] = Math.min(
                                CONFIG.MAX_WATER_PER_CELL,
                                this.waterGrid[tapY][x] + flowRate
                            );
                        }
                    }
                }

                // Update water grid simulation
                this.updateWaterSimulation();
            }

            updateWaterSimulation() {
                // Create a copy of water grid for next frame
                const newWaterGrid = [];
                const newWaterDelay = [];
                for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                    newWaterGrid[y] = [...this.waterGrid[y]];
                    newWaterDelay[y] = [...this.waterDelay[y]];
                }
                
                // Process water physics - multiple passes for better flow
                for (let pass = 0; pass < 3; pass++) { // More passes for complex puzzles
                    // Process from bottom to top for better settling
                    for (let y = CONFIG.GRID_HEIGHT - 1; y >= 0; y--) {
                        for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                            const water = newWaterGrid[y][x];
                            if (water <= CONFIG.MIN_WATER_FLOW) continue;
                            
                            const terrain = this.grid[y][x];
                            
                            // Check if water hits tank
                            if (terrain === TERRAIN.TANK) {
                                const previousLevel = this.fuelLevel;
                                this.fuelLevel = Math.min(100, this.fuelLevel + water * 0.5); // Much slower tank filling
                                newWaterGrid[y][x] = 0;
                                
                                // Check if tank just reached 100%
                                if (!this.tankFull && this.fuelLevel >= 100) {
                                    this.tankFull = true;
                                    this.showingCongrats = true;
                                    this.playSound('powerup'); // Victory sound
                                }
                                
                                // Play water fill sound (more frequent)
                                if (Math.random() < 0.2 && water > 0.1) {
                                    this.playSound('waterFill');
                                }
                                continue;
                            }
                            
                            // Check if water hits power-up
                            for (const powerUp of this.powerUps) {
                                if (!powerUp.collected && 
                                    Math.abs(powerUp.x - x) < 2 && 
                                    Math.abs(powerUp.y - y) < 2) {
                                    powerUp.collected = true;
                                    this.collectedPowerUps.push(powerUp);
                                    this.playSound('powerup');
                                    console.log('Power-up collected:', powerUp.type);
                                }
                            }
                            
                            // Skip if cell is solid
                            if (terrain === TERRAIN.SAND || terrain === TERRAIN.WALL) {
                                newWaterGrid[y][x] = 0;
                                continue;
                            }
                            
                            // Try to flow down - with delay
                            let flowed = false;
                            if (y < CONFIG.GRID_HEIGHT - 1) {
                                const below = this.grid[y + 1][x];
                                if (below === TERRAIN.SKY || below === TERRAIN.TANK) {
                                    // Check if this cell just received water (delay before falling)
                                    if (this.grid[y][x] === TERRAIN.SKY && water > 0 && this.waterGrid[y][x] === 0) {
                                        // New water entering this cell, set delay
                                        newWaterDelay[y][x] = 30; // ~0.5 seconds at 60fps
                                    }
                                    
                                    // Only flow if delay has expired
                                    if (newWaterDelay[y][x] <= 0) {
                                    const belowWater = newWaterGrid[y + 1][x];
                                    const space = CONFIG.MAX_WATER_PER_CELL - belowWater;
                                    if (space > 0) {
                                        const flow = Math.min(water * 0.8, space);
                                        newWaterGrid[y][x] -= flow;
                                        newWaterGrid[y + 1][x] += flow;
                                        flowed = true;
                                        }
                                    } else {
                                        // Decrease delay
                                        newWaterDelay[y][x]--;
                                    }
                                }
                            }
                            
                            // Diagonal flow for better diagonal tunnels
                            if (!flowed && y < CONFIG.GRID_HEIGHT - 1 && newWaterGrid[y][x] > 0.1) {
                                // Try diagonal down-left
                                if (x > 0) {
                                    const diagCell = this.grid[y + 1][x - 1];
                                    const sideCell = this.grid[y][x - 1];
                                    if ((diagCell === TERRAIN.SKY || diagCell === TERRAIN.TANK) &&
                                        (sideCell === TERRAIN.SKY || this.grid[y + 1][x] === TERRAIN.SKY)) {
                                        const diagWater = newWaterGrid[y + 1][x - 1];
                                        const space = CONFIG.MAX_WATER_PER_CELL - diagWater;
                                        if (space > 0.05) {
                                            const flow = Math.min(newWaterGrid[y][x] * 0.25, space * 0.5);
                                            newWaterGrid[y][x] -= flow;
                                            newWaterGrid[y + 1][x - 1] += flow;
                                            flowed = true;
                                        }
                                    }
                                }
                                
                                // Try diagonal down-right
                                if (!flowed && x < CONFIG.GRID_WIDTH - 1) {
                                    const diagCell = this.grid[y + 1][x + 1];
                                    const sideCell = this.grid[y][x + 1];
                                    if ((diagCell === TERRAIN.SKY || diagCell === TERRAIN.TANK) &&
                                        (sideCell === TERRAIN.SKY || this.grid[y + 1][x] === TERRAIN.SKY)) {
                                        const diagWater = newWaterGrid[y + 1][x + 1];
                                        const space = CONFIG.MAX_WATER_PER_CELL - diagWater;
                                        if (space > 0.05) {
                                            const flow = Math.min(newWaterGrid[y][x] * 0.25, space * 0.5);
                                            newWaterGrid[y][x] -= flow;
                                            newWaterGrid[y + 1][x + 1] += flow;
                                            flowed = true;
                                        }
                                    }
                                }
                            }
                            
                            // Horizontal flow - always try if water is present
                            const remaining = newWaterGrid[y][x];
                            if (remaining > 0.1) {
                                // Check horizontal neighbors
                                const canFlowLeft = x > 0 && (this.grid[y][x - 1] === TERRAIN.SKY || this.grid[y][x - 1] === TERRAIN.TANK);
                                const canFlowRight = x < CONFIG.GRID_WIDTH - 1 && (this.grid[y][x + 1] === TERRAIN.SKY || this.grid[y][x + 1] === TERRAIN.TANK);
                                
                                // Also check if there's support below for horizontal flow
                                const hasSupport = y >= CONFIG.GRID_HEIGHT - 1 || 
                                    this.grid[y + 1][x] === TERRAIN.SAND || 
                                    this.grid[y + 1][x] === TERRAIN.WALL ||
                                    newWaterGrid[y + 1][x] > 0.8;
                                
                                if (hasSupport && (canFlowLeft || canFlowRight)) {
                                    // Calculate pressure-based flow
                                    const leftWater = canFlowLeft ? newWaterGrid[y][x - 1] : 1.0;
                                    const rightWater = canFlowRight ? newWaterGrid[y][x + 1] : 1.0;
                                    
                                    // Flow to lower pressure areas
                                    if (canFlowLeft && remaining > leftWater + 0.05) {
                                        const diff = (remaining - leftWater) * 0.3;
                                        newWaterGrid[y][x] -= diff;
                                        newWaterGrid[y][x - 1] = Math.min(CONFIG.MAX_WATER_PER_CELL, newWaterGrid[y][x - 1] + diff);
                                    }
                                    
                                    if (canFlowRight && remaining > rightWater + 0.05) {
                                        const diff = (remaining - rightWater) * 0.3;
                                        newWaterGrid[y][x] -= diff;
                                        newWaterGrid[y][x + 1] = Math.min(CONFIG.MAX_WATER_PER_CELL, newWaterGrid[y][x + 1] + diff);
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Update the water grid and delay
                this.waterGrid = newWaterGrid;
                this.waterDelay = newWaterDelay;
            }
            
            transitionToPhase2() {
                // Immediately switch to phase 2
                this.currentState = GAME_STATE.PHASE2;
                
                // Clear all phase 1 data
                this.waterGrid = [];
                this.dustParticles = [];
                this.waterFlowing = false;
                this.tankFull = false;
                this.showingCongrats = false;
                
                if (this.fuelLevel < 20) {
                    // Insufficient fuel - game over
                    this.gameOver();
                    return;
                }
                
                // Reset timer for boulder phase with scaling based on difficulty
                const boulderCount = this.calculateBoulderCount();
                const baseTime = CONFIG.BOULDER_PHASE_TIME;
                const extraTime = Math.max(0, (boulderCount - 5) * 3000); // 3 extra seconds per boulder over 5
                this.boulderPhaseTimer = baseTime + extraTime;
                this.boulderPhaseStartCountdown = 4000; // 3 second countdown + 1 second pause
                
                // Show power-up selection if any were collected
                if (this.collectedPowerUps.length > 0) {
                    this.showPowerUpSelection();
                } else {
                // Immediately create boulders and start phase 2
                this.createBoulders();
                this.updateUI();
                }
                
                // Debug: Log transition
                console.log('Transitioned to Phase 2, Wave:', this.wave);
            }
            
            showPowerUpSelection() {
                // Show on-screen power-up selection
                this.showingPowerUpSelection = true;
                this.powerUpTypes = [...new Set(this.collectedPowerUps.map(p => p.type))];
            }
            
            selectPowerUp(typeIndex) {
                if (typeIndex >= 0 && typeIndex < this.powerUpTypes.length) {
                    this.activePowerUp = { type: this.powerUpTypes[typeIndex] };
                    console.log('Selected power-up:', this.activePowerUp.type);
                } else {
                    this.activePowerUp = null;
                }
                
                // Clear collected power-ups for next wave
                this.collectedPowerUps = [];
                this.showingPowerUpSelection = false;
                
                // Create boulders and start phase 2
                this.createBoulders();
                this.updateUI();
            }

            calculateBoulderCount() {
                // Calculate boulder count for timer scaling - more gradual progression
                if (this.wave === 1) return 2;
                else if (this.wave === 2) return 3;
                else if (this.wave === 3) return 3;
                else if (this.wave === 4) return 4;
                else if (this.wave === 5) return 4;
                else if (this.wave === 6) return 5;
                else if (this.wave === 7) return 5;
                else return Math.min(6 + Math.floor((this.wave - 8) * 0.5), 10); // Much gentler scaling
            }

            createBoulders() {
                this.boulders = [];
                
                // More gradual difficulty progression
                let count, baseHP, sizeVariation;
                
                // Calculate scale factor based on wave for more room - more aggressive zoom out
                if (this.wave <= 3) {
                    this.scaleFactor = 1.0; // Normal size
                } else if (this.wave <= 4) {
                    this.scaleFactor = 0.65;
                } else if (this.wave <= 5) {
                    this.scaleFactor = 0.5;
                } else if (this.wave <= 6) {
                    this.scaleFactor = 0.4;
                } else if (this.wave <= 8) {
                    this.scaleFactor = 0.3;
                } else {
                    this.scaleFactor = 0.25; // Minimum 25% size for waves 9+
                }
                
                // Update gun size based on scale
                this.gun.width = this.baseGunWidth * this.scaleFactor;
                this.gun.height = this.baseGunHeight * this.scaleFactor;
                this.gun.y = 400 - this.gun.height - 5; // Adjust Y position
                
                if (this.wave === 1) {
                    // Wave 1: Very easy start
                    count = 2;
                    baseHP = 2;
                    sizeVariation = 0;
                } else if (this.wave === 2) {
                    // Wave 2: Slight increase
                    count = 3;
                    baseHP = 3;
                    sizeVariation = 5;
                } else if (this.wave === 3) {
                    // Wave 3: Moderate challenge
                    count = 5;
                    baseHP = 4;
                    sizeVariation = 10;
                } else if (this.wave <= 5) {
                    // Waves 4-5: Gradual increase
                    count = 6 + (this.wave - 3);
                    baseHP = 5 + Math.floor((this.wave - 3) * 0.5);
                    sizeVariation = 15;
                } else if (this.wave <= 8) {
                    // Waves 6-8: Challenging but fair
                    count = 8 + (this.wave - 5);
                    baseHP = 6 + Math.floor((this.wave - 5) * 0.5);
                    sizeVariation = 20;
                } else {
                    // Waves 9+: Hard but manageable
                    count = Math.min(12 + Math.floor((this.wave - 8) * 1.5), 20); // Max 20 boulders
                    baseHP = 8 + Math.floor((this.wave - 8) * 0.8);
                    sizeVariation = 25;
                }
                
                // Create boulders with variety
                for (let i = 0; i < count; i++) {
                    const sizeOffset = (Math.random() - 0.5) * sizeVariation;
                    const baseRadius = 25 + sizeOffset;
                    const radius = baseRadius * this.scaleFactor; // Apply scale factor
                    // Make boulders slower from wave 5 onwards
                    let speed;
                    if (this.wave <= 4) {
                        speed = this.wave > 1 ? 1 + (this.wave - 1) * 0.08 : 1;
                    } else {
                        // Wave 5+: slower speed progression
                        speed = 1.24 + (this.wave - 5) * 0.04; // Much slower increase
                    }
                    
                    // Special boulder types appear earlier and more frequently
                    let boulderType = 'normal';
                    if (this.wave > 3 && Math.random() < Math.min(0.2 + this.wave * 0.05, 0.6)) {
                        boulderType = Math.random() < 0.5 ? 'armored' : 'fast';
                    }
                    
                    this.boulders.push({
                        x: 100 + (i % 5) * 140 + Math.random() * 60,
                        y: -100 - Math.floor(i / 5) * 80 - Math.random() * 50, // Start above screen
                        vx: (Math.random() - 0.5) * 1.0 * speed, // Reduced horizontal speed
                        vy: 0, // No initial downward velocity - gravity will handle it
                        radius: radius,
                        hp: boulderType === 'armored' ? Math.ceil(baseHP * 1.5) : baseHP,
                        maxHP: boulderType === 'armored' ? Math.ceil(baseHP * 1.5) : baseHP,
                        size: radius > 30 ? 3 : (radius > 20 ? 2 : 1),
                        type: boulderType,
                        speedMultiplier: boulderType === 'fast' ? 1.5 : 1,
                        safetyTimer: 3000 // 3 seconds of safety
                    });
                }
            }

            updatePhase2() {
                // Guard against running this when not in phase 2
                if (this.currentState !== GAME_STATE.PHASE2) {
                    return;
                }
                
                // Handle countdown at start of boulder phase
                if (this.boulderPhaseStartCountdown > 0) {
                    this.boulderPhaseStartCountdown -= 16;
                    return; // Don't update anything else during countdown
                }
                
                // Update boulder phase timer
                this.boulderPhaseTimer -= 16; // Assuming 60fps
                
                if (this.boulderPhaseTimer <= 0) {
                    // Time's up! Game over
                    this.gameOver();
                    return;
                }
                
                // Update gun movement (horizontal only) - only if not paused
                if (!this.isPaused) {
                if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
                    this.gun.x = Math.max(20, this.gun.x - CONFIG.GUN_SPEED);
                }
                if (this.keys['ArrowRight'] || this.keys['KeyD']) {
                        this.gun.x = Math.min(800 - this.gun.width - 20, this.gun.x + CONFIG.GUN_SPEED);
                    }
                }

                // Auto-fire system (unlimited ammo in boulder phase) - only if not paused
                if (!this.isPaused) {
                const now = Date.now();
                    const fireRate = this.activePowerUp?.type === 'rapidFire' ? CONFIG.AUTO_FIRE_RATE / 2 : CONFIG.AUTO_FIRE_RATE;
                    if (now - this.lastAutoFire >= fireRate) {
                    this.fireBullet();
                    this.lastAutoFire = now;
                    }
                }

                // Update visual effects
                this.muzzleFlash = Math.max(0, this.muzzleFlash - 2);
                this.cameraShake.intensity *= 0.9;
                this.cameraShake.x = (Math.random() - 0.5) * this.cameraShake.intensity;
                this.cameraShake.y = (Math.random() - 0.5) * this.cameraShake.intensity;

                // Update impact particles
                for (let i = this.impactParticles.length - 1; i >= 0; i--) {
                    const particle = this.impactParticles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2; // gravity
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        this.impactParticles.splice(i, 1);
                    }
                }

                // Update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.x += bullet.vx || 0;
                    bullet.y += bullet.vy || -CONFIG.BULLET_SPEED;
                    
                    if (bullet.y < 0) {
                        this.bullets.splice(i, 1);
                        continue;
                    }
                    
                    // Check boulder collisions - iterate backwards to handle removal
                    let bulletHit = false;
                    for (let j = this.boulders.length - 1; j >= 0; j--) {
                        const boulder = this.boulders[j];
                        if (!boulder || boulder.destroyed) continue; // Skip if boulder was removed or destroyed
                        
                        const dx = bullet.x - boulder.x;
                        const dy = bullet.y - boulder.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < boulder.radius) {
                            this.hitBoulder(j, bullet);
                            this.bullets.splice(i, 1);
                            bulletHit = true;
                            break;
                        }
                    }
                    if (bulletHit) continue;
                }

                // Update boulders with improved physics - iterate backwards for safety
                for (let i = this.boulders.length - 1; i >= 0; i--) {
                    const boulder = this.boulders[i];
                    if (!boulder || boulder.destroyed) continue; // Skip if boulder was removed or destroyed
                    
                    const speedMult = boulder.speedMultiplier || 1;
                    boulder.x += boulder.vx * speedMult;
                    boulder.y += boulder.vy * speedMult;
                    
                    // Boulder-to-boulder collision
                    for (let j = 0; j < i; j++) {
                        const other = this.boulders[j];
                        if (!other || other.destroyed) continue; // Skip if boulder was removed or destroyed
                        const dx = other.x - boulder.x;
                        const dy = other.y - boulder.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = boulder.radius + other.radius;
                        
                        if (distance < minDistance && distance > 0) {
                            // Separate boulders
                            const overlap = minDistance - distance;
                            const separateX = (dx / distance) * overlap * 0.5;
                            const separateY = (dy / distance) * overlap * 0.5;
                            
                            boulder.x -= separateX;
                            boulder.y -= separateY;
                            other.x += separateX;
                            other.y += separateY;
                            
                            // Exchange velocities with energy conservation and damping
                            const normalX = dx / distance;
                            const normalY = dy / distance;
                            const relativeVelX = other.vx - boulder.vx;
                            const relativeVelY = other.vy - boulder.vy;
                            const speed = relativeVelX * normalX + relativeVelY * normalY;
                            
                            if (speed < 0) continue; // Objects separating
                            
                            // Apply collision with damping to prevent crazy bouncing
                            const dampingFactor = 0.5; // Reduce energy transfer
                            boulder.vx += speed * normalX * dampingFactor;
                            boulder.vy += speed * normalY * dampingFactor;
                            other.vx -= speed * normalX * dampingFactor;
                            other.vy -= speed * normalY * dampingFactor;
                            
                            // Apply velocity limits to prevent crazy speeds
                            const maxSpeed = 5; // Reduced from 8
                            boulder.vx = Math.max(-maxSpeed, Math.min(maxSpeed, boulder.vx));
                            boulder.vy = Math.max(-maxSpeed, Math.min(maxSpeed, boulder.vy));
                            other.vx = Math.max(-maxSpeed, Math.min(maxSpeed, other.vx));
                            other.vy = Math.max(-maxSpeed, Math.min(maxSpeed, other.vy));
                        }
                    }
                    
                    // Bounce off walls with variation and controlled energy
                    if (boulder.x <= boulder.radius || boulder.x >= 800 - boulder.radius) {
                        boulder.vx *= -(0.7 + Math.random() * 0.1); // Less energy conservation to prevent crazy bouncing
                        boulder.vx += (Math.random() - 0.5) * CONFIG.BOUNCE_VARIATION * 0.5;
                        boulder.x = Math.max(boulder.radius, Math.min(800 - boulder.radius, boulder.x));
                        this.cameraShake.intensity = CONFIG.CAMERA_SHAKE_INTENSITY * 0.5;
                        
                        // Velocity limit
                        const maxSpeed = 8;
                        boulder.vx = Math.max(-maxSpeed, Math.min(maxSpeed, boulder.vx));
                    }
                    
                    if (boulder.y <= boulder.radius) {
                        // Stop at ceiling and fall down (no bounce)
                        boulder.y = boulder.radius;
                        boulder.vy = 1; // Small downward velocity to start falling
                        // No camera shake for ceiling stop
                    }
                    
                    // Gravity with terminal velocity
                    boulder.vy += 0.2; // Slightly less gravity
                    
                    // Terminal velocity to prevent infinite acceleration
                    const terminalVelocity = 8; // Reduced from 12
                    boulder.vy = Math.min(terminalVelocity, boulder.vy);
                    
                    // Update safety timer
                    if (boulder.safetyTimer > 0) {
                        boulder.safetyTimer -= 16;
                    }
                    
                    // Check gun collision (immediate game over) - but only after safety period
                    if (boulder.safetyTimer <= 0 &&
                        boulder.y + boulder.radius >= this.gun.y &&
                        boulder.x + boulder.radius >= this.gun.x && 
                        boulder.x - boulder.radius <= this.gun.x + this.gun.width) {
                        this.gameOver();
                        return;
                    }
                    
                    // Bounce off bottom with minimum height preservation and controlled energy
                    if (boulder.y >= 400 - boulder.radius) {
                        boulder.y = 400 - boulder.radius;
                        const bounceVel = Math.abs(boulder.vy * 0.85); // More energy conservation for higher bounces
                        boulder.vy = -Math.max(bounceVel, CONFIG.MIN_BOUNCE_HEIGHT);
                        boulder.vy += (Math.random() - 0.5) * CONFIG.BOUNCE_VARIATION;
                        this.cameraShake.intensity = CONFIG.CAMERA_SHAKE_INTENSITY * 0.7;
                        
                        // Velocity limit - allow higher upward velocity for big bounces
                        const maxUpwardSpeed = 16;
                        boulder.vy = Math.max(-maxUpwardSpeed, boulder.vy); // Allow high upward velocity
                    }
                }
                
                // Process destroyed boulders and pending splits
                this.processDestroyedBoulders();

                // Check if all boulders destroyed - with safety check
                if (this.boulders.length === 0 && this.currentState === GAME_STATE.PHASE2) {
                    // Prevent multiple calls
                    if (!this.transitioning) {
                        this.transitioning = true;
                        // Small delay to prevent any race conditions
                        setTimeout(() => {
                            if (this.boulders.length === 0 && this.currentState === GAME_STATE.PHASE2) {
                                this.nextWave();
                            }
                            this.transitioning = false;
                        }, 100);
                    }
                }
            }
            
            processDestroyedBoulders() {
                // Remove destroyed boulders
                this.boulders = this.boulders.filter(boulder => !boulder.destroyed);
                
                // Add split boulders
                if (this.pendingSplits && this.pendingSplits.length > 0) {
                    this.boulders.push(...this.pendingSplits);
                    this.pendingSplits = [];
                    this.dirtDecorations = [];
                }
            }

            hitBoulder(boulderIndex, bullet) {
                // Safety check - ensure boulder exists
                if (boulderIndex < 0 || boulderIndex >= this.boulders.length) {
                    return;
                }
                
                const boulder = this.boulders[boulderIndex];
                if (!boulder) return; // Additional safety check
                
                const damage = bullet?.damage || 1;
                boulder.hp -= damage;
                
                // Impact effects
                this.cameraShake.intensity = CONFIG.CAMERA_SHAKE_INTENSITY * 0.5;
                
                // Play hit sound
                this.playSound('hit');
                
                // Impact particles
                for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                    this.impactParticles.push({
                        x: boulder.x + (Math.random() - 0.5) * boulder.radius,
                        y: boulder.y + (Math.random() - 0.5) * boulder.radius,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 20 + Math.random() * 10,
                        maxLife: 30
                    });
                }
                
                if (boulder.hp <= 0) {
                    this.score += (boulder.size || 1) * 100;
                    
                    // Play boulder destruction sound
                    this.playSound('burst');
                    
                    // Destruction effects
                    this.cameraShake.intensity = CONFIG.CAMERA_SHAKE_INTENSITY;
                    
                    // Enhanced destruction particles with burst effect
                    for (let i = 0; i < CONFIG.PARTICLE_COUNT * 3; i++) {
                        const angle = (Math.PI * 2 * i) / (CONFIG.PARTICLE_COUNT * 3);
                        const speed = 5 + Math.random() * 10;
                        this.impactParticles.push({
                            x: boulder.x,
                            y: boulder.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 30 + Math.random() * 30,
                            maxLife: 60,
                            color: boulder.type === 'armored' ? 'rgba(192, 192, 192,' : 
                                   boulder.type === 'fast' ? 'rgba(255, 100, 100,' : 'rgba(139, 69, 19,',
                            size: 2 + Math.random() * 4
                        });
                    }
                    
                    // Mark boulder as destroyed instead of removing immediately
                    boulder.destroyed = true;
                    
                    if (boulder.size > 1) {
                        // Store split boulder data for later creation
                        if (!this.pendingSplits) this.pendingSplits = [];
                        
                        const newSize = boulder.size - 1;
                                                    const newRadius = boulder.radius * 0.7; // Already scaled
                        
                        for (let i = 0; i < 2; i++) {
                            this.pendingSplits.push({
                                x: boulder.x + (i - 0.5) * 20,
                                y: boulder.y,
                                vx: (i - 0.5) * (2 + Math.random() * 1), // Reduced split velocity
                                vy: -4 - Math.random() * 2, // Reduced upward velocity
                                hp: Math.ceil(boulder.maxHP * 0.6),
                                maxHP: Math.ceil(boulder.maxHP * 0.6),
                                size: newSize,
                                radius: newRadius,
                                type: boulder.type || 'normal',
                                speedMultiplier: boulder.speedMultiplier || 1
                            });
                        }
                    }
                }
            }

            fireBullet() {
                // In phase 2, unlimited ammo
                // Apply power-up effects
                const damage = this.activePowerUp?.type === 'doubleDamage' ? 2 : 1;
                const spread = this.activePowerUp?.type === 'spreadShot' ? 3 : 1;
                
                for (let i = 0; i < spread; i++) {
                    const angle = spread > 1 ? (i - 1) * 0.15 : 0; // Spread angle
                this.bullets.push({
                    x: this.gun.x + this.gun.width / 2,
                            y: this.gun.y,
                            vx: Math.sin(angle) * 3,
                            vy: -CONFIG.BULLET_SPEED,
                            damage: damage,
                            radius: 4 * this.scaleFactor // Scale bullet size too
                        });
                }
                
                // Play shooting sound
                this.playSound('shoot');
                
                // Muzzle flash and recoil effects
                this.muzzleFlash = 10;
                this.cameraShake.intensity = CONFIG.CAMERA_SHAKE_INTENSITY * 0.3;
            }

            nextWave() {
                this.wave++;
                this.showingWaveScreen = true;
                this.waveScreenTimer = 2000; // Show for 2 seconds
                
                // Don't immediately start phase 1, wait for wave screen to finish
                this.transitioning = false; // Reset transitioning flag
                
                // Cycle background
                this.backgroundIndex = (this.backgroundIndex + 1) % this.backgrounds.length;
                this.currentBackground = this.backgrounds[this.backgroundIndex];
                
                // Clear all phase 2 data
                this.bullets = [];
                this.boulders = [];
                this.impactParticles = [];
                this.pendingSplits = []; // Clear any pending boulder splits
                this.dirtDecorations = []; // Clear dirt decorations
                this.activePowerUp = null; // Clear active power-up
                this.collectedPowerUps = []; // Clear collected power-ups
                
                // Cycle background
                this.backgroundIndex = (this.backgroundIndex + 1) % this.backgrounds.length;
                
                // Generate more complex layouts for higher waves
                this.initializeGrid();
                this.addWaveComplexity();
                this.updateUI();
                
            }
            
            startNextWavePhase() {
                // Actually start the next wave phase after the wave screen
                this.currentState = GAME_STATE.PHASE1;
                this.phaseTimer = CONFIG.AMMO_PHASE_TIME;
                this.fuelLevel = 0;
                this.waterFlowing = false;
                this.phaseStarted = false;
                this.countdownTimer = 3000;
                this.showingWaveScreen = false;
                this.waveScreenTimer = 0;
                
                // Initialize grid for wave 1 if needed
                if (this.wave === 1) {
                    this.initializeGrid();
                    this.updateUI();
                }
                
                // Debug: Log wave transition
                console.log('Started Wave:', this.wave, 'Phase 1');
            }

            exitToMenu() {
                // Exit to menu without game over flow
                this.currentState = GAME_STATE.MENU;
                this.showInstructions = false;
                this.showCustomization = false;
                this.showLeaderboard = false;
                this.isPaused = false;
                this.showPauseMenu = false;
                this.showPauseInstructions = false;
                this.showingWaveScreen = false;
                this.waveScreenTimer = 0;
                
                // Reset pause button text
                const pauseButton = document.getElementById('pauseButton');
                if (pauseButton) {
                    pauseButton.textContent = 'Pause';
                }
                
                // Clear all game data
                this.bullets = [];
                this.boulders = [];
                this.waterGrid = [];
                this.dustParticles = [];
                this.impactParticles = [];
                this.pendingSplits = [];
                this.dirtDecorations = [];
                this.transitioning = false;
                this.showingPowerUpSelection = false;
                this.activePowerUp = null;
                this.collectedPowerUps = [];
                this.powerUps = [];
                this.boulderPhaseStartCountdown = 0;
                this.tankFull = false;
                this.showingCongrats = false;
            }

            gameOver() {
                // Set game over state
                this.currentState = GAME_STATE.GAME_OVER;
                this.gameOverName = '';
                this.gameOverNameSubmitted = false;
                
                // Save high score
                const highScore = parseInt(localStorage.getItem('highScore') || '0');
                if (this.score > highScore) {
                    localStorage.setItem('highScore', this.score.toString());
                }
            }
            
            submitGameOverName() {
                const playerName = this.gameOverName.trim() || 'Anonymous';
                this.addToLeaderboard(playerName, this.score, this.wave);
                this.gameOverNameSubmitted = true;
                
                // Show leaderboard for 2 seconds then return to menu
                setTimeout(() => {
                    this.returnToMenuFromGameOver();
                }, 2000);
            }
            
            returnToMenuFromGameOver() {
                // Return to menu
                this.currentState = GAME_STATE.MENU;
                this.showInstructions = false;
                this.showCustomization = false;
                this.showLeaderboard = true; // Show leaderboard after game over
                // Clear all game data
                this.bullets = [];
                this.boulders = [];
                this.waterGrid = [];
                this.dustParticles = [];
                this.impactParticles = [];
                this.pendingSplits = [];
                this.dirtDecorations = [];
                this.transitioning = false;
                this.showingPowerUpSelection = false;
                this.activePowerUp = null;
                this.collectedPowerUps = [];
                this.powerUps = [];
                this.boulderPhaseStartCountdown = 0;
                this.tankFull = false;
                this.showingCongrats = false;
            }
            
            loadLeaderboard() {
                const saved = localStorage.getItem('pipelinePanicLeaderboard');
                return saved ? JSON.parse(saved) : [];
            }
            
            saveLeaderboard() {
                localStorage.setItem('pipelinePanicLeaderboard', JSON.stringify(this.leaderboard));
            }
            
            addToLeaderboard(name, score, wave) {
                this.leaderboard.push({
                    name: name.substring(0, 20), // Limit name length
                    score: score,
                    wave: wave,
                    date: new Date().toLocaleDateString()
                });
                
                // Sort by score (descending) and keep only top 10
                this.leaderboard.sort((a, b) => b.score - a.score);
                this.leaderboard = this.leaderboard.slice(0, 10);
                
                this.saveLeaderboard();
            }

            updateUI() {
                // Hide/show UI based on game state
                const gameUI = document.getElementById('ui');
                const exitButton = document.getElementById('exitButton');
                const pauseButton = document.getElementById('pauseButton');
                
                if (this.currentState === GAME_STATE.MENU || this.currentState === GAME_STATE.GAME_OVER) {
                    if (gameUI) gameUI.style.display = 'none';
                    if (exitButton) exitButton.style.display = 'none';
                    if (pauseButton) pauseButton.style.display = 'none';
                } else {
                    if (gameUI) gameUI.style.display = 'flex';
                    if (exitButton) exitButton.style.display = 'inline-block';
                    if (pauseButton) pauseButton.style.display = 'inline-block';
                    
                    document.getElementById('waveCount').textContent = this.wave;
                    document.getElementById('score').textContent = this.score;
                    
                    // Update timer text
                    const timeRemaining = document.getElementById('timeRemaining');
                    if (this.currentState === GAME_STATE.PHASE1) {
                        timeRemaining.textContent = Math.ceil(this.phaseTimer / 1000);
                    } else if (this.currentState === GAME_STATE.PHASE2) {
                        timeRemaining.textContent = Math.ceil(this.boulderPhaseTimer / 1000);
                    }
                    
                    // Update power-up display
                    const powerUpDisplay = document.getElementById('powerUpDisplay');
                    const activePowerUpText = document.getElementById('activePowerUp');
                    if (this.currentState === GAME_STATE.PHASE2 && this.activePowerUp) {
                        powerUpDisplay.style.display = 'block';
                        const powerUpNames = {
                            'rapidFire': '‚ö° Rapid Fire',
                            'doubleDamage': 'üí• Double Damage',
                            'spreadShot': 'üéØ Spread Shot'
                        };
                        activePowerUpText.textContent = powerUpNames[this.activePowerUp.type] || 'Unknown';
                    } else {
                        powerUpDisplay.style.display = 'none';
                    }
                    
                    // Update tank fill visualization
                    const tankFill = document.getElementById('tankFill');
                    if (tankFill) {
                        tankFill.style.width = (this.fuelLevel) + '%';
                    }
                    
                    const phaseIndicator = document.getElementById('phaseIndicator');
                    const timerFill = document.getElementById('timerFill');
                    
                    if (this.currentState === GAME_STATE.PHASE1) {
                        phaseIndicator.textContent = 'PHASE 1: COLLECT FUEL';
                        const timerPercent = (this.phaseTimer / CONFIG.AMMO_PHASE_TIME) * 100;
                        timerFill.style.width = timerPercent + '%';
                        document.getElementById('ammoCount').textContent = Math.floor(this.fuelLevel) + '%';
                        document.getElementById('timeLeft').textContent = Math.ceil(this.phaseTimer / 1000);
                    } else {
                        let phaseText = 'PHASE 2: DESTROY BOULDERS';
                        // Add scale indicator if needed
                        if (this.scaleFactor < 1.0) {
                            const scalePercent = Math.round(this.scaleFactor * 100);
                            phaseText += ` | üîç Scale: ${scalePercent}%`;
                        }
                        phaseIndicator.textContent = phaseText;
                        
                        // Calculate total time for this wave for accurate percentage
                        const boulderCount = this.calculateBoulderCount();
                        const baseTime = CONFIG.BOULDER_PHASE_TIME;
                        const extraTime = Math.max(0, (boulderCount - 5) * 3000);
                        const totalTime = baseTime + extraTime;
                        const timerPercent = (this.boulderPhaseTimer / totalTime) * 100;
                        timerFill.style.width = timerPercent + '%';
                        document.getElementById('ammoCount').textContent = 'UNLIMITED';
                        document.getElementById('timeLeft').textContent = Math.ceil(this.boulderPhaseTimer / 1000);
                    }
                }
            }

            render() {
                // Apply camera shake
                this.ctx.save();
                this.ctx.translate(this.cameraShake.x, this.cameraShake.y);
                
                // Clear canvas with enhanced dynamic background
                if (this.currentState === GAME_STATE.MENU) {
                    // Menu background gradient
                    const menuGradient = this.ctx.createLinearGradient(0, 0, 0, 400);
                    menuGradient.addColorStop(0, '#87CEEB');
                    menuGradient.addColorStop(0.5, '#6BA6CD');
                    menuGradient.addColorStop(1, '#4682B4');
                    this.ctx.fillStyle = menuGradient;
                    this.ctx.fillRect(-10, -10, 820, 420);
                } else if (this.currentState === GAME_STATE.PHASE1) {
                    // Phase 1 sky gradient
                    const skyGradient = this.ctx.createLinearGradient(0, 0, 0, 400);
                    skyGradient.addColorStop(0, '#87CEEB');
                    skyGradient.addColorStop(0.3, '#98D8E8');
                    skyGradient.addColorStop(1, '#F0E68C');
                    this.ctx.fillStyle = skyGradient;
                    this.ctx.fillRect(-10, -10, 820, 420);
                } else if (this.currentState === GAME_STATE.PHASE2) {
                    // Phase 2 dynamic background based on wave
                    const bgGradient = this.ctx.createLinearGradient(0, 0, 0, 400);
                    const colors = [
                        ['#1a237e', '#283593', '#3949ab'], // Night
                        ['#388e3c', '#43a047', '#66bb6a'], // Forest
                        ['#ff7043', '#ff8a65', '#ffab91'], // Sunset
                        ['#8d6e63', '#a1887f', '#bcaaa4']  // Desert
                    ];
                    const colorSet = colors[this.backgroundIndex % colors.length];
                    bgGradient.addColorStop(0, colorSet[0]);
                    bgGradient.addColorStop(0.5, colorSet[1]);
                    bgGradient.addColorStop(1, colorSet[2]);
                    this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(-10, -10, 820, 420);
                    
                    // Add stars for night background
                    if (this.backgroundIndex % 4 === 0) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        for (let i = 0; i < 50; i++) {
                            const x = (i * 97) % 800;
                            const y = (i * 53) % 200;
                            const size = ((i * 7) % 3) + 1;
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }

                // Only render game states if not showing wave screen
                if (!this.showingWaveScreen) {
                    if (this.currentState === GAME_STATE.MENU) {
                        this.renderMenu();
                    } else if (this.currentState === GAME_STATE.PHASE1) {
                        this.renderPhase1();
                    } else if (this.currentState === GAME_STATE.PHASE2) {
                        this.renderPhase2();
                    } else if (this.currentState === GAME_STATE.GAME_OVER) {
                        this.renderGameOver();
                    }
                }
                
                this.ctx.restore();
                
                // Render power-up selection UI if showing (this should be last to cover everything)
                if (this.showingPowerUpSelection) {
                    this.renderPowerUpSelection();
                }
                
                // Render congratulations screen if showing
                if (this.showingCongrats) {
                    this.renderCongratulations();
                }
                
                // Render pause menu if showing
                if (this.showPauseMenu) {
                    this.renderPauseMenu();
                }
                
                // Render wave screen if showing
                if (this.showingWaveScreen) {
                    this.renderWaveScreen();
                }
            }
            
            renderMenu() {
                // Render menu background
                this.renderMenuBackground();
                
                const centerX = 400;
                const centerY = 160; // Moved buttons higher
                
                if (!this.showInstructions && !this.showCustomization && !this.showLeaderboard) {
                    // Title
                    this.ctx.font = 'bold 72px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    // Title shadow
                    this.ctx.fillStyle = '#000000';
                    this.ctx.fillText('PIPELINE PANIC', centerX + 4, 60 + 4);
                    
                    // Title main
                    const titleGradient = this.ctx.createLinearGradient(0, 20, 0, 100);
                    titleGradient.addColorStop(0, '#FF6B6B');
                    titleGradient.addColorStop(1, '#C44444');
                    this.ctx.fillStyle = titleGradient;
                    this.ctx.fillText('PIPELINE PANIC', centerX, 60);
                    
                    // Play button
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.fillRect(centerX - 100, centerY - 30, 200, 40);
                    this.ctx.strokeStyle = '#2E7D32';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(centerX - 100, centerY - 30, 200, 40);
                    
                    this.ctx.font = 'bold 28px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('PLAY', centerX, centerY - 10);
                    
                    // Instructions button
                    this.ctx.fillStyle = '#2196F3';
                    this.ctx.fillRect(centerX - 100, centerY + 40, 200, 40);
                    this.ctx.strokeStyle = '#1565C0';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(centerX - 100, centerY + 40, 200, 40);
                    
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('INSTRUCTIONS', centerX, centerY + 60);
                    
                    // Customization button
                    this.ctx.fillStyle = '#9C27B0';
                    this.ctx.fillRect(centerX - 100, centerY + 100, 200, 40);
                    this.ctx.strokeStyle = '#6A1B9A';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(centerX - 100, centerY + 100, 200, 40);
                    
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('CUSTOMIZE', centerX, centerY + 120);
                    
                    // Leaderboard button
                    this.ctx.fillStyle = '#FF9800';
                    this.ctx.fillRect(centerX - 100, centerY + 160, 200, 40);
                    this.ctx.strokeStyle = '#E65100';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(centerX - 100, centerY + 160, 200, 40);
                    
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('LEADERBOARD', centerX, centerY + 180);
                    
                    // High score display box in bottom left
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(20, 340, 180, 40);
                    this.ctx.strokeStyle = '#FFD700';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(20, 340, 180, 40);
                    
                    this.ctx.font = '18px Arial';
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('High Score: ' + (localStorage.getItem('highScore') || 0), 110, 365);
                    
                    // Display selected skin preview on the right
                    this.ctx.textAlign = 'center'; // Reset alignment for skin preview
                    this.renderSkinPreview(600, 180);
                    
                } else if (this.showInstructions) {
                    // Instructions screen with dark background
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    this.ctx.fillRect(0, 0, 800, 400);
                    
                    // Title
                    this.ctx.font = 'bold 36px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('HOW TO PLAY', centerX, 50);
                    
                    // Phase 1 Box (Left)
                    this.ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                    this.ctx.fillRect(50, 80, 320, 240);
                    this.ctx.strokeStyle = '#4CAF50';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(50, 80, 320, 240);
                    
                    // Phase 1 Title
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PHASE 1: FUEL COLLECTION', 210, 110);
                    
                    // Phase 1 Instructions
                    this.ctx.font = '16px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'left';
                    const phase1Instructions = [
                        '‚Ä¢ Click and drag to dig tunnels',
                        '  through the dirt',
                        '‚Ä¢ Guide water from tap to tank',
                        '‚Ä¢ Fill tank to at least 20%',
                        '  (100% to skip timer)',
                        '‚Ä¢ Collect power-up diamonds',
                        '  for Phase 2 boosts',
                        '‚Ä¢ Watch out for obstacles!'
                    ];
                    
                    let y = 140;
                    for (const line of phase1Instructions) {
                        this.ctx.fillText(line, 70, y);
                        y += 22;
                    }
                    
                    // Phase 2 Box (Right)
                    this.ctx.fillStyle = 'rgba(255, 152, 0, 0.2)';
                    this.ctx.fillRect(430, 80, 320, 240);
                    this.ctx.strokeStyle = '#FF9800';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(430, 80, 320, 240);
                    
                    // Phase 2 Title
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.fillStyle = '#FF9800';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PHASE 2: BOULDER BATTLE', 590, 110);
                    
                    // Phase 2 Instructions
                    this.ctx.font = '16px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'left';
                    const phase2Instructions = [
                        '‚Ä¢ Use A/D or ‚Üê/‚Üí keys to',
                        '  move your cannon',
                        '‚Ä¢ Auto-fire shoots at',
                        '  bouncing boulders',
                        '‚Ä¢ Destroy all boulders before',
                        '  time runs out!',
                        '‚Ä¢ Larger boulders split when',
                        '  destroyed into smaller ones'
                    ];
                    
                    y = 140;
                    for (const line of phase2Instructions) {
                        this.ctx.fillText(line, 450, y);
                        y += 22;
                    }
                    
                    // Back button
                    this.ctx.fillStyle = '#2196F3';
                    this.ctx.fillRect(centerX - 50, 340, 100, 40);
                    this.ctx.strokeStyle = '#1565C0';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(centerX - 50, 340, 100, 40);
                    
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('BACK', centerX, 360);
                } else if (this.showCustomization) {
                    // Customization screen
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.fillRect(50, 50, 700, 300);
                    
                    this.ctx.font = 'bold 36px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('CUSTOMIZE YOUR GAME', centerX, 90);
                    
                    // Shooter skins
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText('Shooter Skins:', 80, 130);
                    
                    let skinX = 80;
                    for (const [key, skin] of Object.entries(this.skins)) {
                        const isSelected = this.selectedSkin === key;
                        
                        // Button background
                        this.ctx.fillStyle = isSelected ? skin.color : '#444444';
                        this.ctx.fillRect(skinX, 140, 120, 40);
                        
                        if (isSelected) {
                            this.ctx.strokeStyle = '#FFD700';
                            this.ctx.lineWidth = 3;
                            this.ctx.strokeRect(skinX, 140, 120, 40);
                        }
                        
                        this.ctx.font = '16px Arial';
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(skin.name, skinX + 60, 165);
                        
                        skinX += 130;
                    }
                    
                    // Fuel colors
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText('Fuel Colors:', 80, 210);
                    
                    let fuelX = 80;
                    for (const [key, fuel] of Object.entries(this.fuelColors)) {
                        const isSelected = this.selectedFuelColor === key;
                        
                        // Button background
                        this.ctx.fillStyle = isSelected ? fuel.color : '#444444';
                        this.ctx.fillRect(fuelX, 220, 120, 40);
                        
                        if (isSelected) {
                            this.ctx.strokeStyle = '#FFD700';
                            this.ctx.lineWidth = 3;
                            this.ctx.strokeRect(fuelX, 220, 120, 40);
                        }
                        
                        this.ctx.font = '16px Arial';
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(fuel.name, fuelX + 60, 245);
                        
                        fuelX += 130;
                    }
                    
                    // Back button
                    this.ctx.fillStyle = '#FF5722';
                    this.ctx.fillRect(centerX - 50, 290, 100, 40);
                    this.ctx.strokeStyle = '#D84315';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(centerX - 50, 290, 100, 40);
                    
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('BACK', centerX, 310);
                } else if (this.showLeaderboard) {
                    // Leaderboard screen
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.fillRect(50, 50, 700, 300);
                    
                    this.ctx.font = 'bold 36px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('LEADERBOARD', centerX, 90);
                    
                    // Leaderboard headers
                    this.ctx.font = 'bold 18px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.fillText('Rank', 100, 130);
                    this.ctx.fillText('Name', 180, 130);
                    this.ctx.fillText('Score', 400, 130);
                    this.ctx.fillText('Wave', 500, 130);
                    this.ctx.fillText('Date', 600, 130);
                    
                    // Draw leaderboard entries
                    this.ctx.font = '16px Arial';
                    this.leaderboard = this.loadLeaderboard(); // Refresh leaderboard
                    const displayCount = Math.min(this.leaderboard.length, 8);
                    
                    for (let i = 0; i < displayCount; i++) {
                        const entry = this.leaderboard[i];
                        const y = 160 + i * 25;
                        
                        // Highlight top 3
                        if (i < 3) {
                            const colors = ['#FFD700', '#C0C0C0', '#CD7F32']; // Gold, Silver, Bronze
                            this.ctx.fillStyle = colors[i];
                        } else {
                            this.ctx.fillStyle = '#FFFFFF';
                        }
                        
                        this.ctx.fillText(`#${i + 1}`, 100, y);
                        this.ctx.fillText(entry.name, 180, y);
                        this.ctx.fillText(entry.score.toString(), 400, y);
                        this.ctx.fillText(entry.wave.toString(), 500, y);
                        this.ctx.fillText(entry.date, 600, y);
                    }
                    
                    if (this.leaderboard.length === 0) {
                        this.ctx.fillStyle = '#CCCCCC';
                        this.ctx.textAlign = 'center';
                        this.ctx.font = '20px Arial';
                        this.ctx.fillText('No scores yet. Be the first to play!', centerX, 200);
                    }
                    
                    // Back button
                    this.ctx.fillStyle = '#FF5722';
                    this.ctx.fillRect(centerX - 50, 340, 100, 40);
                    this.ctx.strokeStyle = '#D84315';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(centerX - 50, 340, 100, 40);
                    
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('BACK', centerX, 360);
                }
            }
            
            handlePowerUpClick() {
                const centerX = 400;
                const baseY = 150;
                const buttonHeight = 60;
                const buttonWidth = 400;
                const spacing = 10;
                
                // Check which power-up button was clicked
                for (let i = 0; i < this.powerUpTypes.length; i++) {
                    const buttonY = baseY + i * (buttonHeight + spacing);
                    
                    if (this.mouse.x > centerX - buttonWidth/2 && this.mouse.x < centerX + buttonWidth/2 &&
                        this.mouse.y > buttonY && this.mouse.y < buttonY + buttonHeight) {
                        this.selectPowerUp(i);
                        this.playSound('powerup');
                        break;
                    }
                }
                
                // Check skip button
                const skipY = baseY + this.powerUpTypes.length * (buttonHeight + spacing) + 20;
                if (this.mouse.x > centerX - 100 && this.mouse.x < centerX + 100 &&
                    this.mouse.y > skipY && this.mouse.y < skipY + 40) {
                    this.selectPowerUp(-1); // No power-up
                }
            }
            
            renderPowerUpSelection() {
                // Completely cover background to hide boulder phase
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                this.ctx.fillRect(0, 0, 800, 400);
                
                // Title
                this.ctx.font = 'bold 36px Arial';
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Choose Your Power-Up!', 400, 80);
                
                const powerUpInfo = {
                    'rapidFire': {
                        name: 'Rapid Fire',
                        desc: 'Double your shooting speed!',
                        color: '#FFD700',
                        icon: '‚ö°'
                    },
                    'doubleDamage': {
                        name: 'Double Damage',
                        desc: 'Each shot deals 2x damage!',
                        color: '#FF69B4',
                        icon: 'üí•'
                    },
                    'spreadShot': {
                        name: 'Spread Shot',
                        desc: 'Fire 3 bullets at once!',
                        color: '#00CED1',
                        icon: 'üéØ'
                    }
                };
                
                // Render power-up buttons
                const centerX = 400;
                const baseY = 150;
                const buttonHeight = 60;
                const buttonWidth = 400;
                const spacing = 10;
                
                for (let i = 0; i < this.powerUpTypes.length; i++) {
                    const type = this.powerUpTypes[i];
                    const info = powerUpInfo[type];
                    const buttonY = baseY + i * (buttonHeight + spacing);
                    
                    // Button background with gradient
                    const gradient = this.ctx.createLinearGradient(centerX - buttonWidth/2, buttonY, centerX + buttonWidth/2, buttonY);
                    gradient.addColorStop(0, info.color);
                    gradient.addColorStop(0.5, this.adjustColor(info.color, 1.2));
                    gradient.addColorStop(1, info.color);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(centerX - buttonWidth/2, buttonY, buttonWidth, buttonHeight);
                    
                    // Button border
                    this.ctx.strokeStyle = '#FFFFFF';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(centerX - buttonWidth/2, buttonY, buttonWidth, buttonHeight);
                    
                    // Icon
                    this.ctx.font = '32px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(info.icon, centerX - buttonWidth/2 + 20, buttonY + 40);
                    
                    // Name
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(info.name, centerX - buttonWidth/2 + 70, buttonY + 25);
                    
                    // Description
                    this.ctx.font = '16px Arial';
                    this.ctx.fillStyle = '#EEEEEE';
                    this.ctx.fillText(info.desc, centerX - buttonWidth/2 + 70, buttonY + 45);
                }
                
                // Skip button
                const skipY = baseY + this.powerUpTypes.length * (buttonHeight + spacing) + 20;
                this.ctx.fillStyle = '#666666';
                this.ctx.fillRect(centerX - 100, skipY, 200, 40);
                this.ctx.strokeStyle = '#444444';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(centerX - 100, skipY, 200, 40);
                
                this.ctx.font = '20px Arial';
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Skip Power-Up', centerX, skipY + 25);
            }
            
            handleCongratsClick() {
                // Check if "Next" button was clicked
                const centerX = 400;
                const buttonY = 260;
                
                if (this.mouse.x > centerX - 80 && this.mouse.x < centerX + 80 &&
                    this.mouse.y > buttonY && this.mouse.y < buttonY + 40) {
                    // Skip to phase 2
                    this.showingCongrats = false;
                    this.transitionToPhase2();
                }
            }
            
            renderCongratulations() {
                // Darken background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, 800, 400);
                
                // Success message
                this.ctx.font = 'bold 36px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#00FF00';
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 3;
                this.ctx.strokeText('CONGRATULATIONS!', 400, 120);
                this.ctx.fillText('CONGRATULATIONS!', 400, 120);
                
                // Sub message
                this.ctx.font = '24px Arial';
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillText('You filled the tank before time ran out!', 400, 170);
                
                // Bonus info
                this.ctx.font = '20px Arial';
                this.ctx.fillStyle = '#FFD700';
                this.ctx.fillText('Tank filled: 100%', 400, 210);
                
                // Next button
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.fillRect(320, 260, 160, 40);
                this.ctx.strokeStyle = '#2E7D32';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(320, 260, 160, 40);
                
                this.ctx.font = 'bold 20px Arial';
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillText('NEXT', 400, 285);
            }
            
            togglePause() {
                if (this.currentState === GAME_STATE.PHASE1 || this.currentState === GAME_STATE.PHASE2) {
                    this.isPaused = !this.isPaused;
                    this.showPauseMenu = this.isPaused;
                    
                    const pauseButton = document.getElementById('pauseButton');
                    if (pauseButton) {
                        pauseButton.textContent = this.isPaused ? 'Resume' : 'Pause';
                    }
                }
            }
            
            renderWaveScreen() {
                // Dark overlay
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, 800, 400);
                
                // Wave text
                this.ctx.save();
                this.ctx.font = 'bold 72px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Animated scale effect
                const scale = 1 + Math.sin(Date.now() * 0.003) * 0.1;
                this.ctx.translate(400, 200);
                this.ctx.scale(scale, scale);
                
                // Text with gradient
                const gradient = this.ctx.createLinearGradient(-200, 0, 200, 0);
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.5, '#FFA500');
                gradient.addColorStop(1, '#FF6347');
                
                this.ctx.fillStyle = gradient;
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 4;
                
                const waveText = `WAVE ${this.wave}`;
                this.ctx.strokeText(waveText, 0, 0);
                this.ctx.fillText(waveText, 0, 0);
                
                this.ctx.restore();
                
                // Sub text
                this.ctx.font = '24px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#FFFFFF';
                if (this.wave === 1) {
                    this.ctx.fillText('Get ready to start your adventure!', 400, 280);
                } else {
                    this.ctx.fillText('Get ready for increased difficulty!', 400, 280);
                }
            }
            
            handlePauseMenuClick() {
                const centerX = 400;
                const buttonWidth = 200;
                const buttonHeight = 50;
                const baseY = 130;
                const spacing = 60;
                
                // Resume button
                if (this.mouse.x > centerX - buttonWidth/2 && this.mouse.x < centerX + buttonWidth/2 &&
                    this.mouse.y > baseY && this.mouse.y < baseY + buttonHeight) {
                    this.togglePause();
                }
                
                // Instructions button
                else if (this.mouse.x > centerX - buttonWidth/2 && this.mouse.x < centerX + buttonWidth/2 &&
                         this.mouse.y > baseY + spacing && this.mouse.y < baseY + spacing + buttonHeight) {
                    this.showPauseInstructions = true;
                }
                
                // Quit button
                else if (this.mouse.x > centerX - buttonWidth/2 && this.mouse.x < centerX + buttonWidth/2 &&
                         this.mouse.y > baseY + spacing * 2 && this.mouse.y < baseY + spacing * 2 + buttonHeight) {
                    if (confirm('Are you sure you want to quit to main menu?')) {
                        this.isPaused = false;
                        this.showPauseMenu = false;
                        this.exitToMenu();
                    }
                }
                
                // Back button from instructions
                if (this.showPauseInstructions) {
                    if (this.mouse.x > centerX - 60 && this.mouse.x < centerX + 60 &&
                        this.mouse.y > 340 && this.mouse.y < 380) {
                        this.showPauseInstructions = false;
                    }
                }
            }
            
            renderPauseMenu() {
                // Dark overlay
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, 800, 400);
                
                if (this.showPauseInstructions) {
                    // Instructions screen
                    this.ctx.font = 'bold 36px Arial';
                    this.ctx.fillStyle = '#00FFFF';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('GAME INSTRUCTIONS', 400, 50);
                    
                    this.ctx.font = '18px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillStyle = '#FFFFFF';
                    const instructions = [
                        'PHASE 1 - FUEL COLLECTION:',
                        '‚Ä¢ Click and drag to dig tunnels through dirt',
                        '‚Ä¢ Guide water from tap to tank below',
                        '‚Ä¢ Fill tank to at least 20% (100% to skip timer)',
                        '‚Ä¢ Collect power-up diamonds for Phase 2 boosts',
                        '',
                        'PHASE 2 - BOULDER DESTRUCTION:',
                        '‚Ä¢ Use A/D or ‚Üê/‚Üí keys to move your cannon',
                        '‚Ä¢ Cannon fires automatically with unlimited ammo',
                        '‚Ä¢ Destroy all boulders before time runs out',
                        '‚Ä¢ Larger boulders split when destroyed!'
                    ];
                    
                    let y = 90;
                    for (const line of instructions) {
                        this.ctx.fillText(line, 100, y);
                        y += 25;
                    }
                    
                    // Back button
                    this.ctx.fillStyle = '#2196F3';
                    this.ctx.fillRect(340, 340, 120, 40);
                    this.ctx.strokeStyle = '#1565C0';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(340, 340, 120, 40);
                    
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('BACK', 400, 365);
                } else {
                    // Main pause menu
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', 400, 70);
                    
                    const centerX = 400;
                    const buttonWidth = 200;
                    const buttonHeight = 50;
                    const baseY = 130;
                    const spacing = 60;
                    
                    // Resume button
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.fillRect(centerX - buttonWidth/2, baseY, buttonWidth, buttonHeight);
                    this.ctx.strokeStyle = '#2E7D32';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(centerX - buttonWidth/2, baseY, buttonWidth, buttonHeight);
                    
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('RESUME', centerX, baseY + 32);
                    
                    // Instructions button
                    this.ctx.fillStyle = '#2196F3';
                    this.ctx.fillRect(centerX - buttonWidth/2, baseY + spacing, buttonWidth, buttonHeight);
                    this.ctx.strokeStyle = '#1565C0';
                    this.ctx.strokeRect(centerX - buttonWidth/2, baseY + spacing, buttonWidth, buttonHeight);
                    
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('INSTRUCTIONS', centerX, baseY + spacing + 32);
                    
                    // Quit button
                    this.ctx.fillStyle = '#FF5722';
                    this.ctx.fillRect(centerX - buttonWidth/2, baseY + spacing * 2, buttonWidth, buttonHeight);
                    this.ctx.strokeStyle = '#D84315';
                    this.ctx.strokeRect(centerX - buttonWidth/2, baseY + spacing * 2, buttonWidth, buttonHeight);
                    
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('QUIT', centerX, baseY + spacing * 2 + 32);
                    
                    // Tip
                    this.ctx.font = '16px Arial';
                    this.ctx.fillStyle = '#CCCCCC';
                    this.ctx.fillText('Press ESC to resume', centerX, 330);
                }
            }
            
            adjustColor(color, brightness) {
                // Adjust color brightness for gradients
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                const adjust = (c) => Math.min(255, Math.floor(c * brightness));
                
                return `#${adjust(r).toString(16).padStart(2, '0')}${adjust(g).toString(16).padStart(2, '0')}${adjust(b).toString(16).padStart(2, '0')}`;
            }
            
            handleGameOverClick() {
                const centerX = 400;
                const centerY = 200;
                
                if (!this.gameOverNameSubmitted) {
                    // Check submit button
                    if (this.mouse.x > centerX - 80 && this.mouse.x < centerX + 80 &&
                        this.mouse.y > centerY + 40 && this.mouse.y < centerY + 80) {
                        this.submitGameOverName();
                    }
                } else {
                    // Check restart button
                    if (this.mouse.x > centerX - 80 && this.mouse.x < centerX + 80 &&
                        this.mouse.y > centerY + 100 && this.mouse.y < centerY + 140) {
                        this.returnToMenuFromGameOver();
                    }
                }
            }
            
            renderGameOver() {
                // Dark overlay
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, 800, 400);
                
                const centerX = 400;
                const centerY = 200;
                
                // Game Over title
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#FF6B6B';
                this.ctx.fillText('GAME OVER', centerX, 80);
                
                // Score and wave
                this.ctx.font = '24px Arial';
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillText(`Wave: ${this.wave} | Score: ${this.score}`, centerX, 120);
                
                if (!this.gameOverNameSubmitted) {
                    // Name input prompt
                    this.ctx.font = '20px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('Enter your name for the leaderboard:', centerX, centerY - 40);
                    
                    // Name input box
                    this.ctx.fillStyle = '#333333';
                    this.ctx.fillRect(centerX - 150, centerY - 20, 300, 40);
                    this.ctx.strokeStyle = '#FFD700';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(centerX - 150, centerY - 20, 300, 40);
                    
                    // Display typed name
                    this.ctx.font = '18px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(this.gameOverName + (Date.now() % 1000 < 500 ? '_' : ''), centerX - 140, centerY + 5);
                    
                    // Submit button
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.fillRect(centerX - 80, centerY + 40, 160, 40);
                    this.ctx.strokeStyle = '#2E7D32';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(centerX - 80, centerY + 40, 160, 40);
                    
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Submit', centerX, centerY + 65);
                    
                    // Instructions
                    this.ctx.font = '14px Arial';
                    this.ctx.fillStyle = '#CCCCCC';
                    this.ctx.fillText('Type your name and press Enter or click Submit', centerX, centerY + 110);
                } else {
                    // Show leaderboard position
                    this.ctx.font = '24px Arial';
                    this.ctx.fillStyle = '#FFD700';
                    const position = this.leaderboard.findIndex(entry => entry.score === this.score && entry.name === (this.gameOverName || 'Anonymous')) + 1;
                    if (position > 0 && position <= 10) {
                        this.ctx.fillText(`You ranked #${position} on the leaderboard!`, centerX, centerY);
                    } else {
                        this.ctx.fillText('Thanks for playing!', centerX, centerY);
                    }
                    
                    // Restart button
                    this.ctx.fillStyle = '#2196F3';
                    this.ctx.fillRect(centerX - 80, centerY + 100, 160, 40);
                    this.ctx.strokeStyle = '#1565C0';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(centerX - 80, centerY + 100, 160, 40);
                    
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText('Main Menu', centerX, centerY + 125);
                }
            }
            
            renderSkinPreview(x, y) {
                // Draw a preview of the selected gun skin
                const skin = this.skins[this.selectedSkin];
                const gunGradient = this.ctx.createLinearGradient(x, y, x, y + 40);
                gunGradient.addColorStop(0, skin.gradient[0]);
                gunGradient.addColorStop(0.5, skin.gradient[1]);
                gunGradient.addColorStop(1, skin.gradient[2]);
                
                this.ctx.fillStyle = gunGradient;
                this.ctx.fillRect(x, y, 80, 40);
                
                // Different visual designs for each skin preview
                const detailColor = this.adjustColor(skin.gradient[2], 0.7);
                
                if (this.selectedSkin === 'default') {
                    // Classic design
                    this.ctx.fillStyle = detailColor;
                    this.ctx.fillRect(x + 10, y + 16, 60, 8);
                    this.ctx.fillRect(x + 35, y - 10, 10, 10);
                    
                    this.ctx.fillStyle = this.adjustColor(skin.gradient[1], 0.8);
                    this.ctx.fillRect(x + 4, y + 4, 12, 32);
                    this.ctx.fillRect(x + 64, y + 4, 12, 32);
                    
                } else if (this.selectedSkin === 'red') {
                    // Crimson design
                    this.ctx.fillStyle = detailColor;
                    this.ctx.fillRect(x + 35, y - 16, 10, 16);
                    for (let i = 0; i < 3; i++) {
                        const fx = x + 16 + i * 20;
                        this.ctx.beginPath();
                        this.ctx.moveTo(fx, y + 36);
                        this.ctx.lineTo(fx + 6, y + 10);
                        this.ctx.lineTo(fx + 12, y + 36);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                    
                } else if (this.selectedSkin === 'green') {
                    // Forest design
                    this.ctx.fillStyle = detailColor;
                    this.ctx.fillRect(x + 36, y - 12, 8, 12);
                    
                    this.ctx.fillStyle = this.adjustColor('#4ADE80', 0.8);
                    for (let i = 0; i < 4; i++) {
                        const lx = x + 10 + i * 18;
                        const ly = y + 20;
                        this.ctx.beginPath();
                        this.ctx.ellipse(lx, ly, 6, 10, Math.PI / 4, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                } else if (this.selectedSkin === 'purple') {
                    // Royal design
                    this.ctx.fillStyle = detailColor;
                    for (let i = 0; i < 3; i++) {
                        const cx = x + 30 + i * 10;
                        this.ctx.fillRect(cx, y - 8 - (i === 1 ? 8 : 0), 8, 8 + (i === 1 ? 8 : 0));
                    }
                    
                    this.ctx.fillStyle = this.adjustColor('#E0AAFF', 1.2);
                    for (let i = 0; i < 3; i++) {
                        const gx = x + 16 + i * 22;
                        this.ctx.beginPath();
                        this.ctx.moveTo(gx, y + 10);
                        this.ctx.lineTo(gx + 6, y + 16);
                        this.ctx.lineTo(gx, y + 22);
                        this.ctx.lineTo(gx - 6, y + 16);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                    
                } else if (this.selectedSkin === 'gold') {
                    // Golden design
                    this.ctx.fillStyle = detailColor;
                    this.ctx.fillRect(x + 30, y - 12, 8, 12);
                    this.ctx.fillRect(x + 42, y - 12, 8, 12);
                    
                    this.ctx.fillStyle = this.adjustColor('#FFF59D', 1.2);
                    for (let i = 0; i < 3; i++) {
                        const sx = x + 16 + i * 24;
                        const sy = y + 20;
                        this.ctx.beginPath();
                        for (let j = 0; j < 5; j++) {
                            const angle = (j * 72 - 90) * Math.PI / 180;
                            const r = j % 2 === 0 ? 6 : 3;
                            const px = sx + Math.cos(angle) * r;
                            const py = sy + Math.sin(angle) * r;
                            if (j === 0) this.ctx.moveTo(px, py);
                            else this.ctx.lineTo(px, py);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                }
                
                // Gun outline
                this.ctx.strokeStyle = detailColor;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x, y, 80, 40);
                
                // Label
                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Selected Skin', x + 40, y + 60);
            }
            
            renderBackgroundDecorations() {
                // Render sky gradient based on time of day
                const gradient = this.ctx.createLinearGradient(0, 0, 0, 400);
                
                switch(this.currentBackground) {
                    case 'morning':
                        gradient.addColorStop(0, '#87CEEB'); // Sky blue
                        gradient.addColorStop(0.5, '#FFE4B5'); // Moccasin
                        gradient.addColorStop(1, '#FFD700'); // Gold
                        break;
                    case 'afternoon':
                        gradient.addColorStop(0, '#00BFFF'); // Deep sky blue
                        gradient.addColorStop(0.7, '#87CEEB'); // Sky blue
                        gradient.addColorStop(1, '#98FB98'); // Pale green
                        break;
                    case 'evening':
                        gradient.addColorStop(0, '#FF6B6B'); // Sunset red
                        gradient.addColorStop(0.3, '#FF8E53'); // Orange
                        gradient.addColorStop(0.6, '#FFA07A'); // Light salmon
                        gradient.addColorStop(1, '#4A148C'); // Deep purple
                        break;
                    case 'night':
                        gradient.addColorStop(0, '#000428'); // Dark blue
                        gradient.addColorStop(0.5, '#004e92'); // Medium blue
                        gradient.addColorStop(1, '#000428'); // Dark blue
                        break;
                }
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, 800, 400);
                
                // Stars for night time
                if (this.currentBackground === 'night') {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    for (let i = 0; i < 50; i++) {
                        const x = (i * 137) % 800;
                        const y = (i * 97) % 200;
                        const size = (i % 3) + 1;
                        this.ctx.fillRect(x, y, size, size);
                    }
                }
                
                // Sun/Moon
                if (this.currentBackground === 'morning' || this.currentBackground === 'afternoon') {
                    // Sun
                    this.ctx.fillStyle = '#FFD700';
                    const sunY = this.currentBackground === 'morning' ? 60 : 40;
                    this.ctx.beginPath();
                    this.ctx.arc(700, sunY, 25, 0, Math.PI * 2);
                    this.ctx.fill();
                } else if (this.currentBackground === 'night') {
                    // Moon
                    this.ctx.fillStyle = '#F0E68C';
                    this.ctx.beginPath();
                    this.ctx.arc(700, 50, 20, 0, Math.PI * 2);
                    this.ctx.fill();
                    // Moon craters
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.beginPath();
                    this.ctx.arc(695, 45, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(705, 52, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Pixelated clouds with appropriate colors
                const cloudColor = this.currentBackground === 'night' ? 
                    'rgba(100, 100, 100, 0.4)' : 
                    this.currentBackground === 'evening' ? 
                    'rgba(255, 200, 200, 0.5)' : 
                    'rgba(255, 255, 255, 0.6)';
                
                this.ctx.fillStyle = cloudColor;
                
                // Cloud 1 - slow drift to the right
                const cloud1X = ((Date.now() * 0.005) % 900) - 100;
                this.drawPixelCloud(cloud1X, 30, 1);
                
                // Cloud 2 - slower drift
                const cloud2X = ((Date.now() * 0.003) % 900) - 100;
                this.drawPixelCloud(cloud2X, 50, 2);
                
                // Cloud 3 - slowest drift
                const cloud3X = ((Date.now() * 0.002) % 900) - 100;
                this.drawPixelCloud(cloud3X, 40, 3);
            }
            
            drawPixelCloud(x, y, type) {
                this.ctx.save();
                this.ctx.translate(x, y);
                
                const pixelSize = 4;
                
                // Different cloud patterns
                let cloudPattern;
                if (type === 1) {
                    // Small cloud
                    cloudPattern = [
                        [0, 0, 1, 1, 0, 0],
                        [0, 1, 1, 1, 1, 0],
                        [1, 1, 1, 1, 1, 1],
                        [0, 1, 1, 1, 1, 0]
                    ];
                } else if (type === 2) {
                    // Medium cloud
                    cloudPattern = [
                        [0, 0, 1, 1, 1, 0, 0, 0],
                        [0, 1, 1, 1, 1, 1, 0, 0],
                        [1, 1, 1, 1, 1, 1, 1, 0],
                        [1, 1, 1, 1, 1, 1, 1, 1],
                        [0, 1, 1, 1, 1, 1, 1, 0]
                    ];
                } else {
                    // Large cloud
                    cloudPattern = [
                        [0, 0, 0, 1, 1, 1, 0, 0, 0],
                        [0, 1, 1, 1, 1, 1, 1, 1, 0],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [0, 1, 1, 1, 1, 1, 1, 1, 0],
                        [0, 0, 1, 1, 1, 1, 1, 0, 0]
                    ];
                }
                
                // Draw pixelated cloud
                for (let row = 0; row < cloudPattern.length; row++) {
                    for (let col = 0; col < cloudPattern[row].length; col++) {
                        if (cloudPattern[row][col] === 1) {
                            this.ctx.fillRect(
                                col * pixelSize - (cloudPattern[row].length * pixelSize) / 2,
                                row * pixelSize - (cloudPattern.length * pixelSize) / 2,
                                pixelSize,
                                pixelSize
                            );
                        }
                    }
                }
                
                this.ctx.restore();
            }
            
            renderMenuBackground() {
                // Render dirt texture background for menu
                for (let y = 12; y < 80; y++) {
                    for (let x = 0; x < 160; x++) {
                        const px = x * CONFIG.CELL_SIZE;
                        const py = y * CONFIG.CELL_SIZE;
                        
                        // Varied sand colors for texture
                        const sandVariation = (x * 7 + y * 13) % 5;
                        const sandColors = ['#C19A6B', '#B8860B', '#D2691E', '#CD853F', '#DEB887'];
                        this.ctx.fillStyle = sandColors[sandVariation];
                        this.ctx.fillRect(px, py, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE);
                    }
                }
                
                // Add a decorative pipe at the top
                const pipeX = 400;
                const pipeY = 30;
                const pipeWidth = 100;
                
                // Pipe base
                this.ctx.fillStyle = '#333333';
                this.ctx.fillRect(pipeX - pipeWidth/2 - 5, pipeY - 20, pipeWidth + 10, 25);
                
                // Pipe body with gradient
                const pipeGradient = this.ctx.createLinearGradient(pipeX - pipeWidth/2, pipeY, pipeX + pipeWidth/2, pipeY);
                pipeGradient.addColorStop(0, '#555555');
                pipeGradient.addColorStop(0.5, '#777777');
                pipeGradient.addColorStop(1, '#555555');
                this.ctx.fillStyle = pipeGradient;
                this.ctx.fillRect(pipeX - pipeWidth/2, pipeY - 15, pipeWidth, 30);
                
                // Pipe end
                this.ctx.fillStyle = '#666666';
                this.ctx.fillRect(pipeX - pipeWidth/2 - 10, pipeY + 15, pipeWidth + 20, 15);
                
                // Pipe highlights
                this.ctx.fillStyle = '#999999';
                this.ctx.fillRect(pipeX - pipeWidth/2, pipeY - 15, pipeWidth, 3);
                
                // Water droplets animation
                for (let i = 0; i < 3; i++) {
                    const dropY = (Date.now() * 0.1 + i * 100) % 300 + 50;
                    const dropX = pipeX + (i - 1) * 15;
                    const fuelColor = this.fuelColors[this.selectedFuelColor] || this.fuelColors.blue;
                    this.ctx.fillStyle = fuelColor.color;
                    this.ctx.beginPath();
                    this.ctx.arc(dropX, dropY, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            renderPhase1() {
                // Draw background decorations with time of day
                this.renderBackgroundDecorations();
                
                // Render grid
                for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                    for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                        const terrain = this.grid[y][x];
                        const px = x * CONFIG.CELL_SIZE;
                        const py = y * CONFIG.CELL_SIZE;
                        
                        switch (terrain) {
                            case TERRAIN.SKY:
                                // Already sky blue background
                                break;
                            case TERRAIN.SAND:
                                // Create irregular dirt patterns using pseudo-random noise
                                const noise1 = Math.sin(x * 0.3 + y * 0.7) * Math.cos(y * 0.2 - x * 0.5);
                                const noise2 = Math.sin((x + y) * 0.15) * Math.cos((x - y) * 0.25);
                                const noise = (noise1 + noise2 + 2) / 4; // Normalize to 0-1
                                
                                // Select dirt color based on noise - more uniform orange/brown
                                const baseColor = '#CD853F'; // Peru - main dirt color
                                const dirtColors = ['#D2691E', '#CD853F', '#CD853F', '#CD853F', '#BC8F3F']; // Mostly the same color
                                const colorIndex = Math.floor(noise * dirtColors.length);
                                this.ctx.fillStyle = dirtColors[colorIndex];
                                this.ctx.fillRect(px, py, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE);
                                
                                // Add subtle texture details
                                if (noise > 0.8) {
                                    // Very subtle darker patches
                                    this.ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
                                    this.ctx.fillRect(px + 2, py + 2, CONFIG.CELL_SIZE - 4, CONFIG.CELL_SIZE - 4);
                                } else if (noise < 0.2) {
                                    // Very subtle lighter patches
                                    this.ctx.fillStyle = 'rgba(255, 222, 173, 0.1)';
                                    this.ctx.fillRect(px + 1, py + 1, CONFIG.CELL_SIZE - 2, CONFIG.CELL_SIZE - 2);
                                }
                                
                                // Random dirt particles
                                if ((x * 17 + y * 23) % 13 === 0) {
                                    this.ctx.fillStyle = '#8B4513';
                                    this.ctx.fillRect(px + 1, py + 1, 2, 2);
                                }
                                
                                // Check if this position originally had grass
                                if (this.grassGrid[y] && this.grassGrid[y][x]) {
                                    // Draw grass on top
                                    const grassGradient = this.ctx.createLinearGradient(px, py, px, py + 6);
                                    grassGradient.addColorStop(0, '#228B22');
                                    grassGradient.addColorStop(0.5, '#32CD32');
                                    grassGradient.addColorStop(1, '#3CB371');
                                    this.ctx.fillStyle = grassGradient;
                                    this.ctx.fillRect(px, py, CONFIG.CELL_SIZE, 4);
                                    
                                    // Add grass blades
                                    this.ctx.strokeStyle = '#228B22';
                                    this.ctx.lineWidth = 1;
                                    for (let i = 0; i < CONFIG.CELL_SIZE; i += 3) {
                                        const height = 2 + Math.sin(x * 1.5 + i * 0.5) * 2;
                                        this.ctx.beginPath();
                                        this.ctx.moveTo(px + i, py + 3);
                                        this.ctx.lineTo(px + i + Math.sin(i) * 0.5, py - height);
                                        this.ctx.stroke();
                                    }
                                }
                                break;
                            case TERRAIN.WALL:
                                // Rock texture gradient
                                const wallGradient = this.ctx.createLinearGradient(px, py, px + CONFIG.CELL_SIZE, py + CONFIG.CELL_SIZE);
                                wallGradient.addColorStop(0, '#8B7D6B');
                                wallGradient.addColorStop(0.5, '#6B5D4F');
                                wallGradient.addColorStop(1, '#4A3C28');
                                this.ctx.fillStyle = wallGradient;
                                this.ctx.fillRect(px, py, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE);
                                
                                // Rock edges
                                this.ctx.strokeStyle = '#3A2F20';
                                this.ctx.lineWidth = 0.5;
                                this.ctx.strokeRect(px, py, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE);
                                break;
                            case TERRAIN.TANK:
                                // Don't render individual tank cells, we'll draw the whole tank
                                break;
                        }
                    }
                }
                
                // Render tank as a single unit with better visuals
                const tankX = (this.tankX || 0) * CONFIG.CELL_SIZE;
                const tankY = (this.tankY || 60) * CONFIG.CELL_SIZE;
                const tankWidth = 32 * CONFIG.CELL_SIZE;
                const tankHeight = 20 * CONFIG.CELL_SIZE;
                
                // Tank body gradient
                const tankGradient = this.ctx.createLinearGradient(tankX, tankY, tankX, tankY + tankHeight);
                tankGradient.addColorStop(0, '#707070');
                tankGradient.addColorStop(0.5, '#909090');
                tankGradient.addColorStop(1, '#505050');
                
                // Draw tank body
                this.ctx.fillStyle = tankGradient;
                this.ctx.fillRect(tankX, tankY, tankWidth, tankHeight);
                
                // Tank rim
                this.ctx.strokeStyle = '#303030';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(tankX, tankY, tankWidth, tankHeight);
                
                // Inner rim highlight
                this.ctx.strokeStyle = '#B0B0B0';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(tankX + 4, tankY + 4, tankWidth - 8, tankHeight - 8);
                
                // Tank markings
                this.ctx.fillStyle = '#404040';
                this.ctx.fillRect(tankX, tankY + tankHeight - 10, tankWidth, 10);
                
                // Rivets
                this.ctx.fillStyle = '#606060';
                for (let i = 10; i < tankWidth - 10; i += 20) {
                    this.ctx.beginPath();
                    this.ctx.arc(tankX + i, tankY + 8, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Render tank fill level (gradual filling)
                if (this.fuelLevel > 0) {
                    const fillHeight = tankHeight * (this.fuelLevel / 100);
                    const fillY = tankY + (tankHeight - fillHeight);
                    
                    // Water gradient matching the selected fuel color
                    const fuelColor = this.fuelColors[this.selectedFuelColor] || this.fuelColors.blue;
                    const rgb = this.hexToRgb(fuelColor.color);
                    const waterGradient = this.ctx.createLinearGradient(tankX, fillY, tankX, tankY + tankHeight);
                    waterGradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.9)`);
                    waterGradient.addColorStop(0.3, `rgba(${rgb.r * 0.8}, ${rgb.g * 0.8}, ${rgb.b * 0.8}, 0.95)`);
                    waterGradient.addColorStop(1, `rgba(${rgb.r * 0.6}, ${rgb.g * 0.6}, ${rgb.b * 0.6}, 1)`);
                    
                    this.ctx.fillStyle = waterGradient;
                    this.ctx.fillRect(tankX + 4, fillY, tankWidth - 8, fillHeight - 4);
                    
                    // Surface effects
                    if (this.fuelLevel > 5) {
                        // Animated water surface
                        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        
                        for (let x = 0; x < tankWidth - 8; x += 2) {
                            const waveY = Math.sin(Date.now() * 0.002 + x * 0.05) * 3;
                            if (x === 0) {
                                this.ctx.moveTo(tankX + 4 + x, fillY + waveY);
                            } else {
                                this.ctx.lineTo(tankX + 4 + x, fillY + waveY);
                            }
                        }
                        this.ctx.stroke();
                        
                        // Surface highlights
                        for (let x = 0; x < tankWidth - 8; x += 15) {
                            if (Math.sin(Date.now() * 0.001 + x * 0.2) > 0.5) {
                                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                                this.ctx.fillRect(tankX + 4 + x, fillY + 1, 10, 2);
                            }
                        }
                    }
                }
                
                // Render dust particles with variation
                for (const dust of this.dustParticles) {
                    const alpha = dust.life / dust.maxLife;
                    this.ctx.fillStyle = dust.color ? `${dust.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}` : `rgba(139, 69, 19, ${alpha * 0.8})`;
                    this.ctx.beginPath();
                    const size = dust.size || 2;
                    this.ctx.arc(dust.x, dust.y, size * alpha, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Render countdown timer if not started
                if (!this.phaseStarted) {
                    this.ctx.save();
                    this.ctx.font = 'bold 72px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const seconds = Math.ceil(this.countdownTimer / 1000);
                    if (seconds > 0) {
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        this.ctx.fillRect(0, 0, 800, 400);
                        
                            // Countdown number
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.lineWidth = 4;
                        const text = seconds.toString();
                        this.ctx.strokeText(text, 400, 200);
                        this.ctx.fillText(text, 400, 200);
                            
                            // Instructions
                            this.ctx.font = '24px Arial';
                            this.ctx.fillStyle = '#FFD700';
                            this.ctx.strokeStyle = '#000000';
                            this.ctx.lineWidth = 2;
                            const instruction = 'Fill the tank with fuel (at least 20%)!';
                            this.ctx.strokeText(instruction, 400, 280);
                            this.ctx.fillText(instruction, 400, 280);
                    } else {
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        this.ctx.fillRect(0, 0, 800, 400);
                        
                        this.ctx.fillStyle = '#00FF00';
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.lineWidth = 4;
                        this.ctx.strokeText('GO!', 400, 200);
                        this.ctx.fillText('GO!', 400, 200);
                    }
                    this.ctx.restore();
                }
                
                // Render tap/pipe at top
                if (this.phaseStarted || this.countdownTimer <= 500) {
                    const tapX = (this.tapX || CONFIG.TAP_X) * CONFIG.CELL_SIZE;
                    const tapY = (this.tapY || CONFIG.TAP_Y) * CONFIG.CELL_SIZE;
                    const tapWidth = CONFIG.TAP_WIDTH * CONFIG.CELL_SIZE;
                    
                    // Draw pipe base
                    this.ctx.fillStyle = '#333333';
                    this.ctx.fillRect(tapX - tapWidth/2 - 2, tapY - 20, tapWidth + 4, 15);
                    
                    // Draw pipe
                    const pipeGradient = this.ctx.createLinearGradient(tapX - tapWidth/2, tapY - 15, tapX + tapWidth/2, tapY - 15);
                    pipeGradient.addColorStop(0, '#555555');
                    pipeGradient.addColorStop(0.5, '#777777');
                    pipeGradient.addColorStop(1, '#555555');
                    this.ctx.fillStyle = pipeGradient;
                    this.ctx.fillRect(tapX - tapWidth/2, tapY - 15, tapWidth, 20);
                    
                    // Draw tap end
                    this.ctx.fillStyle = '#666666';
                    this.ctx.fillRect(tapX - tapWidth/2 - 5, tapY + 5, tapWidth + 10, 12);
                    
                    // Draw highlights
                    this.ctx.fillStyle = '#999999';
                    this.ctx.fillRect(tapX - tapWidth/2, tapY - 15, tapWidth, 3);
                    this.ctx.fillStyle = '#888888';
                    this.ctx.fillRect(tapX - tapWidth/2 - 5, tapY + 5, tapWidth + 10, 2);
                }
                
                // Render water from grid
                for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                    for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                        const water = this.waterGrid[y][x];
                        if (water > CONFIG.MIN_WATER_FLOW) {
                            const px = x * CONFIG.CELL_SIZE;
                            const py = y * CONFIG.CELL_SIZE;
                            
                            // Calculate water height based on amount
                            const height = CONFIG.CELL_SIZE * water;
                            const topY = py + CONFIG.CELL_SIZE - height;
                            
                            // Create gradient for water depth with selected fuel color
                            const fuelColor = this.fuelColors[this.selectedFuelColor] || this.fuelColors.blue;
                            const rgb = this.hexToRgb(fuelColor.color);
                            const gradient = this.ctx.createLinearGradient(px, topY, px, py + CONFIG.CELL_SIZE);
                            gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.85)`);
                            gradient.addColorStop(0.3, `rgba(${rgb.r * 0.8}, ${rgb.g * 0.8}, ${rgb.b * 0.8}, 0.9)`);
                            gradient.addColorStop(1, `rgba(${rgb.r * 0.6}, ${rgb.g * 0.6}, ${rgb.b * 0.6}, 0.95)`);
                            
                            this.ctx.fillStyle = gradient;
                            this.ctx.fillRect(px, topY, CONFIG.CELL_SIZE, height);
                            
                            // Add surface highlights and reflections
                            if (water > 0.7 && y > 0 && this.waterGrid[y-1][x] < 0.1) {
                                // Main highlight
                                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                                this.ctx.fillRect(px, topY, CONFIG.CELL_SIZE, 2);
                                
                                // Shimmer effect
                                if (Math.sin(Date.now() * 0.001 + x * 0.5) > 0.5) {
                                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                                    this.ctx.fillRect(px + 1, topY + 1, CONFIG.CELL_SIZE - 2, 1);
                                }
                            }
                            
                            // Bubble effects for deep water
                            if (water > 0.9 && Math.random() < 0.001) {
                                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                                this.ctx.beginPath();
                                this.ctx.arc(px + CONFIG.CELL_SIZE/2, py - 2, 1, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                        }
                    }
                }
                
                // Render dirt decorations
                for (const decoration of this.dirtDecorations) {
                    const px = decoration.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
                    const py = decoration.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
                    const scale = decoration.scale || 1;
                    const rotation = decoration.rotation || 0;
                    
                    this.ctx.save();
                    this.ctx.translate(px, py);
                    this.ctx.rotate(rotation);
                    this.ctx.scale(scale, scale);
                    
                    switch(decoration.type) {
                        case 'bone':
                            // Draw a more obvious bone
                            this.ctx.fillStyle = '#FFFACD'; // Light yellow
                            this.ctx.strokeStyle = '#DEB887'; // Darker outline
                            this.ctx.lineWidth = 1.5;
                            
                            // Bone shaft - thicker and longer
                            this.ctx.fillRect(-8, -2.5, 16, 5);
                            this.ctx.strokeRect(-8, -2.5, 16, 5);
                            
                            // Bone ends - bigger and more pronounced
                            this.ctx.beginPath();
                            // Left end - double bulb
                            this.ctx.arc(-8, -2, 3, 0, Math.PI * 2);
                            this.ctx.arc(-8, 2, 3, 0, Math.PI * 2);
                            // Right end - double bulb
                            this.ctx.arc(8, -2, 3, 0, Math.PI * 2);
                            this.ctx.arc(8, 2, 3, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.stroke();
                            
                            // Add center detail for realism
                            this.ctx.strokeStyle = '#D2B48C';
                            this.ctx.lineWidth = 0.5;
                            this.ctx.beginPath();
                            this.ctx.moveTo(-4, 0);
                            this.ctx.lineTo(4, 0);
                            this.ctx.stroke();
                            break;
                            
                        case 'rock':
                            // Draw a small rock
                            this.ctx.fillStyle = '#696969';
                            this.ctx.strokeStyle = '#2F4F4F';
                            this.ctx.lineWidth = 1;
                            this.ctx.beginPath();
                            this.ctx.ellipse(0, 0, 6, 4, 0, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.stroke();
                            
                            // Add some detail
                            this.ctx.fillStyle = '#595959';
                            this.ctx.beginPath();
                            this.ctx.ellipse(-2, -1, 2, 1.5, 0.3, 0, Math.PI * 2);
                            this.ctx.fill();
                            break;
                            
                        case 'stone':
                            // Draw an angular stone
                            this.ctx.fillStyle = '#778899';
                            this.ctx.strokeStyle = '#2F4F4F';
                            this.ctx.lineWidth = 1;
                            this.ctx.beginPath();
                            this.ctx.moveTo(-4, 2);
                            this.ctx.lineTo(0, -4);
                            this.ctx.lineTo(4, -1);
                            this.ctx.lineTo(2, 3);
                            this.ctx.lineTo(-3, 4);
                            this.ctx.closePath();
                            this.ctx.fill();
                            this.ctx.stroke();
                            
                            // Add crack detail
                            this.ctx.strokeStyle = '#5F6F7F';
                            this.ctx.lineWidth = 0.5;
                            this.ctx.beginPath();
                            this.ctx.moveTo(-1, -2);
                            this.ctx.lineTo(1, 2);
                            this.ctx.stroke();
                            break;
                            
                        case 'fossil':
                            // Draw a shell fossil
                            this.ctx.strokeStyle = '#8B7355';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            // Spiral pattern
                            for (let i = 0; i < 3; i++) {
                                const radius = 2 + i * 2;
                                this.ctx.arc(0, 0, radius, Math.PI, Math.PI * 2.5);
                            }
                            this.ctx.stroke();
                            
                            // Add center detail
                            this.ctx.fillStyle = '#8B7355';
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, 1, 0, Math.PI * 2);
                            this.ctx.fill();
                            break;
                    }
                    
                    this.ctx.restore();
                }
                
                // Render power-up diamonds
                for (const powerUp of this.powerUps) {
                    if (!powerUp.collected) {
                        const px = powerUp.x * CONFIG.CELL_SIZE;
                        const py = powerUp.y * CONFIG.CELL_SIZE;
                        const size = CONFIG.CELL_SIZE * 2;
                        
                        // Diamond shape
                        this.ctx.save();
                        this.ctx.translate(px, py);
                        
                        // Diamond gradient
                        const diamondGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                        if (powerUp.type === 'rapidFire') {
                            diamondGradient.addColorStop(0, '#FFD700');
                            diamondGradient.addColorStop(0.5, '#FFA500');
                            diamondGradient.addColorStop(1, '#FF8C00');
                        } else if (powerUp.type === 'doubleDamage') {
                            diamondGradient.addColorStop(0, '#FF69B4');
                            diamondGradient.addColorStop(0.5, '#FF1493');
                            diamondGradient.addColorStop(1, '#C71585');
                        } else {
                            diamondGradient.addColorStop(0, '#00CED1');
                            diamondGradient.addColorStop(0.5, '#00BFFF');
                            diamondGradient.addColorStop(1, '#4169E1');
                        }
                        
                        this.ctx.fillStyle = diamondGradient;
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -size);
                        this.ctx.lineTo(size, 0);
                        this.ctx.lineTo(0, size);
                        this.ctx.lineTo(-size, 0);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Diamond shine
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -size * 0.8);
                        this.ctx.lineTo(size * 0.3, -size * 0.3);
                        this.ctx.lineTo(0, 0);
                        this.ctx.lineTo(-size * 0.3, -size * 0.3);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Sparkle effect
                        const time = Date.now() * 0.002;
                        const sparkle = Math.sin(time + powerUp.x + powerUp.y) * 0.5 + 0.5;
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${sparkle * 0.8})`;
                        for (let i = 0; i < 4; i++) {
                            const angle = (Math.PI / 2) * i + time * 0.5;
                            const dist = size * 1.5;
                            this.ctx.beginPath();
                            this.ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        this.ctx.restore();
                    }
                }
            }

            renderPhase2() {
                // Don't render anything if power-up selection is showing
                if (this.showingPowerUpSelection) {
                    return;
                }
                
                // Render countdown if active
                if (this.boulderPhaseStartCountdown > 0) {
                    // Darken background
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, 800, 400);
                    
                    this.ctx.font = 'bold 72px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const seconds = Math.ceil(this.boulderPhaseStartCountdown / 1000);
                    if (seconds > 0) {
                        // Countdown number
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.lineWidth = 4;
                        const text = seconds.toString();
                        this.ctx.strokeText(text, 400, 200);
                        this.ctx.fillText(text, 400, 200);
                        
                        // Instructions
                        this.ctx.font = '24px Arial';
                        this.ctx.fillStyle = '#FF6B6B';
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.lineWidth = 2;
                        const instruction = 'Destroy ALL boulders before time runs out!';
                        this.ctx.strokeText(instruction, 400, 280);
                        this.ctx.fillText(instruction, 400, 280);
                        
                        // Boulder count and scale info
                        this.ctx.font = '20px Arial';
                        this.ctx.fillStyle = '#FFD700';
                        const boulderInfo = `${this.boulders.length} boulders incoming!`;
                        this.ctx.strokeText(boulderInfo, 400, 320);
                        this.ctx.fillText(boulderInfo, 400, 320);
                        
                        // Scale indicator
                        if (this.scaleFactor < 1.0) {
                            this.ctx.font = '16px Arial';
                            this.ctx.fillStyle = '#00CED1';
                            const scaleInfo = `Arena scaled to ${Math.round(this.scaleFactor * 100)}% for more space`;
                            this.ctx.strokeText(scaleInfo, 400, 350);
                            this.ctx.fillText(scaleInfo, 400, 350);
                        }
                    } else {
                        this.ctx.fillStyle = '#00FF00';
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.lineWidth = 4;
                        this.ctx.strokeText('GO!', 400, 200);
                        this.ctx.fillText('GO!', 400, 200);
                    }
                    return; // Don't render game elements during countdown
                }
                
                // Draw background decorations with time of day
                this.renderBackgroundDecorations();
                
                // Render impact particles with enhanced effects
                for (const particle of this.impactParticles) {
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.fillStyle = particle.color ? `${particle.color}${alpha})` : `rgba(255, 165, 0, ${alpha})`;
                    this.ctx.beginPath();
                    const size = (particle.size || 3) * alpha;
                    this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Add glow effect for larger particles
                    if (size > 2) {
                        this.ctx.fillStyle = particle.color ? `${particle.color}${alpha * 0.3})` : `rgba(255, 200, 0, ${alpha * 0.3})`;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, size * 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    }
                }
                
                // Render enhanced gun
                // Gun barrel gradient based on selected skin
                const skin = this.skins[this.selectedSkin];
                const gunGradient = this.ctx.createLinearGradient(this.gun.x, this.gun.y, this.gun.x, this.gun.y + this.gun.height);
                gunGradient.addColorStop(0, skin.gradient[0]);
                gunGradient.addColorStop(0.5, skin.gradient[1]);
                gunGradient.addColorStop(1, skin.gradient[2]);
                
                // Gun body
                this.ctx.fillStyle = gunGradient;
                this.ctx.fillRect(this.gun.x, this.gun.y, this.gun.width, this.gun.height);
                
                // Different visual designs for each skin
                const detailColor = this.adjustColor(skin.gradient[2], 0.7);
                
                if (this.selectedSkin === 'default') {
                    // Classic design - simple with center line
                    this.ctx.fillStyle = detailColor;
                    this.ctx.fillRect(this.gun.x + 5, this.gun.y + 8, this.gun.width - 10, 4);
                    this.ctx.fillRect(this.gun.x + this.gun.width/2 - 2, this.gun.y - 5, 4, 5);
                    
                    // Side panels
                    this.ctx.fillStyle = this.adjustColor(skin.gradient[1], 0.8);
                    this.ctx.fillRect(this.gun.x + 2, this.gun.y + 2, 6, this.gun.height - 4);
                    this.ctx.fillRect(this.gun.x + this.gun.width - 8, this.gun.y + 2, 6, this.gun.height - 4);
                    
                } else if (this.selectedSkin === 'red') {
                    // Crimson design - aggressive with spikes
                    this.ctx.fillStyle = detailColor;
                    // Main barrel
                    this.ctx.fillRect(this.gun.x + this.gun.width/2 - 3, this.gun.y - 8, 6, 8);
                    // Flame patterns
                    for (let i = 0; i < 3; i++) {
                        const x = this.gun.x + 8 + i * 12;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, this.gun.y + this.gun.height - 2);
                        this.ctx.lineTo(x + 3, this.gun.y + 5);
                        this.ctx.lineTo(x + 6, this.gun.y + this.gun.height - 2);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                    
                } else if (this.selectedSkin === 'green') {
                    // Forest design - organic with leaves
                    this.ctx.fillStyle = detailColor;
                    // Center vine
                    this.ctx.fillRect(this.gun.x + this.gun.width/2 - 2, this.gun.y - 6, 4, 6);
                    
                    // Leaf patterns
                    this.ctx.fillStyle = this.adjustColor('#4ADE80', 0.8);
                    for (let i = 0; i < 4; i++) {
                        const x = this.gun.x + 5 + i * 10;
                        const y = this.gun.y + 7;
                        this.ctx.beginPath();
                        this.ctx.ellipse(x, y, 4, 6, Math.PI / 4, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                } else if (this.selectedSkin === 'purple') {
                    // Royal design - elegant with gems
                    this.ctx.fillStyle = detailColor;
                    // Crown-like top
                    for (let i = 0; i < 3; i++) {
                        const x = this.gun.x + this.gun.width/2 - 6 + i * 6;
                        this.ctx.fillRect(x, this.gun.y - 4 - (i === 1 ? 4 : 0), 4, 4 + (i === 1 ? 4 : 0));
                    }
                    
                    // Gem accents
                    this.ctx.fillStyle = this.adjustColor('#E0AAFF', 1.2);
                    for (let i = 0; i < 3; i++) {
                        const x = this.gun.x + 10 + i * 13;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, this.gun.y + 5);
                        this.ctx.lineTo(x + 3, this.gun.y + 8);
                        this.ctx.lineTo(x, this.gun.y + 11);
                        this.ctx.lineTo(x - 3, this.gun.y + 8);
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                    
                } else if (this.selectedSkin === 'gold') {
                    // Golden design - luxurious with stars
                    this.ctx.fillStyle = detailColor;
                    // Double barrel
                    this.ctx.fillRect(this.gun.x + this.gun.width/2 - 5, this.gun.y - 6, 4, 6);
                    this.ctx.fillRect(this.gun.x + this.gun.width/2 + 1, this.gun.y - 6, 4, 6);
                    
                    // Star decorations
                    this.ctx.fillStyle = this.adjustColor('#FFF59D', 1.2);
                    for (let i = 0; i < 3; i++) {
                        const cx = this.gun.x + 10 + i * 15;
                        const cy = this.gun.y + 10;
                        this.ctx.beginPath();
                        for (let j = 0; j < 5; j++) {
                            const angle = (j * 72 - 90) * Math.PI / 180;
                            const r = j % 2 === 0 ? 4 : 2;
                            const x = cx + Math.cos(angle) * r;
                            const y = cy + Math.sin(angle) * r;
                            if (j === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                }
                
                // Gun outline
                this.ctx.strokeStyle = detailColor;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(this.gun.x, this.gun.y, this.gun.width, this.gun.height);
                
                // Muzzle flash effect
                if (this.muzzleFlash > 0) {
                    this.ctx.fillStyle = `rgba(255, 255, 0, ${this.muzzleFlash / 10})`;
                    this.ctx.beginPath();
                    this.ctx.arc(this.gun.x + this.gun.width / 2, this.gun.y, 
                               this.muzzleFlash * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Render bullets with trails
                this.ctx.fillStyle = '#FFD700';
                for (const bullet of this.bullets) {
                    // Bullet trail
                    this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    this.ctx.fillRect(bullet.x - 1, bullet.y, 2, 10);
                    
                    // Bullet
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bullet.radius || 4, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Render boulders with enhanced visuals
                for (const boulder of this.boulders) {
                    // Boulder shadow
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.ellipse(boulder.x + 3, 400 - 5, boulder.radius * 0.8, boulder.radius * 0.3, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Boulder body with gradient effect based on type
                    const gradient = this.ctx.createRadialGradient(
                        boulder.x - boulder.radius * 0.3, boulder.y - boulder.radius * 0.3, 0,
                        boulder.x, boulder.y, boulder.radius
                    );
                    
                    if (boulder.type === 'armored') {
                        // Metallic armored boulder
                        gradient.addColorStop(0, '#C0C0C0');
                        gradient.addColorStop(0.5, '#808080');
                        gradient.addColorStop(1, '#404040');
                    } else if (boulder.type === 'fast') {
                        // Red-tinted fast boulder
                        gradient.addColorStop(0, '#FF9999');
                        gradient.addColorStop(0.5, '#CC6666');
                        gradient.addColorStop(1, '#993333');
                    } else {
                        // Normal boulder
                        gradient.addColorStop(0, '#B8A595');
                        gradient.addColorStop(0.5, '#8B7355');
                        gradient.addColorStop(1, '#5D4E37');
                    }
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(boulder.x, boulder.y, boulder.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Boulder texture/details
                    if (boulder.type === 'armored') {
                        // Metal plates
                        this.ctx.strokeStyle = '#606060';
                        this.ctx.lineWidth = 2;
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 3) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(boulder.x, boulder.y);
                            this.ctx.lineTo(
                                boulder.x + Math.cos(angle) * boulder.radius * 0.8,
                                boulder.y + Math.sin(angle) * boulder.radius * 0.8
                            );
                            this.ctx.stroke();
                        }
                    } else if (boulder.type === 'fast') {
                        // Speed lines
                        this.ctx.strokeStyle = 'rgba(255, 200, 0, 0.6)';
                        this.ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(boulder.x - boulder.radius - 10, boulder.y - 10 + i * 10);
                            this.ctx.lineTo(boulder.x - boulder.radius + 5, boulder.y - 10 + i * 10);
                            this.ctx.stroke();
                        }
                    }
                    
                    // Boulder outline
                    this.ctx.strokeStyle = boulder.type === 'armored' ? '#303030' : 
                                          boulder.type === 'fast' ? '#CC3333' : '#2F4F4F';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(boulder.x, boulder.y, boulder.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // HP display with background
                    const hpRatio = boulder.hp / boulder.maxHP;
                    const hpColor = hpRatio > 0.6 ? '#00FF00' : hpRatio > 0.3 ? '#FFFF00' : '#FF0000';
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(boulder.x - 20, boulder.y - boulder.radius - 25, 40, 20);
                    
                    // HP bar
                    this.ctx.fillStyle = '#333333';
                    this.ctx.fillRect(boulder.x - 18, boulder.y - boulder.radius - 23, 36, 6);
                    this.ctx.fillStyle = hpColor;
                    this.ctx.fillRect(boulder.x - 18, boulder.y - boulder.radius - 23, 36 * hpRatio, 6);
                    
                    // HP text
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(boulder.hp, boulder.x, boulder.y - boulder.radius - 10);
                    
                    // Safety indicator - show shield if boulder is still safe
                    if (boulder.safetyTimer > 0) {
                        this.ctx.save();
                        // Pulsing effect
                        const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 0.8;
                        this.ctx.globalAlpha = 0.6 * pulse;
                        
                        // Shield bubble
                        this.ctx.strokeStyle = '#00FFFF';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(boulder.x, boulder.y, boulder.radius + 10, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // Shield icon
                        this.ctx.fillStyle = '#00FFFF';
                        this.ctx.font = 'bold 16px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('üõ°Ô∏è', boulder.x, boulder.y - boulder.radius - 35);
                        
                        this.ctx.restore();
                    }
                }
            }

            gameLoop() {
                // Handle wave screen timer
                if (this.showingWaveScreen) {
                    this.waveScreenTimer -= 16; // ~60fps
                    if (this.waveScreenTimer <= 0) {
                        this.startNextWavePhase();
                    }
                }
                
                // Update game logic
                if (!this.isPaused && !this.showingWaveScreen) {
                if (this.currentState === GAME_STATE.PHASE1) {
                        if (!this.showingCongrats) {
                    this.updatePhase1();
                        }
                } else if (this.currentState === GAME_STATE.PHASE2) {
                        if (!this.showingPowerUpSelection) {
                    this.updatePhase2();
                        }
                    }
                }
                
                // Update UI
                this.updateUI();
                
                // Render
                this.render();
                
                // Continue loop
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new PipelinePanicGame();
        });
    </script>
</body>
</html>
